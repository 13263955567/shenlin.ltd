title: SVN 和 Git
categories: Git
tags:
  - Git
  - SVN

---

<!--more-->

### svn 和 git

1.	Subversion属于集中式的版本控制系统
Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。

2.	Git属于分布式的版本控制系统
与SVN不同，Git记录版本历史只关心文件数据的整体是否发生变化。Git 并不保存文件内容前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一连接。

在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。

•	Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的
克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人
•	Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。

3.  SVN 工作区和版本库
Subversion 的工作区和版本库物理上分开,Subversion的工作区是一份版本库在某个历史状态下的快照
•	Subversion的工作区中每一个目录下都包含一个名为 .svn 的控制目录
（隐藏的目录），该目录的作用是：
① 标识工作区和版本库的对应关系。
② 包含一份该子目录下检出文件的原始拷贝。

4. Git 的版本库和工作区如影随形

•	Git 的版本库和工作区在同一个目录下，工作区的根目录有一个.git的子
目录，这个名为 .git的目录就是版本库本身，它是Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。

•	版本库可以脱离工作区而存在，成为 bare（赤裸）版本库。可以用 –bare 
参数来创建。但是工作区不能脱离版本库而存在，即工作区的根目录下必须有一个名为 .git 的版本库克隆文件。

5. 保证git库安全

在一个磁盘分区中创建版本库（最好是用 –bare 参数创建），然后在另外的磁盘分区中克隆一个新的作为工作区。在工作区的提交要不时的PUSH到另外分区的版本库，这样就实现了本地的数据镜像。你甚至可以在本地创建更多的版本库镜像，安全性要比Subversion的一个库加上一个工作区安全。

6. 全局版本号 和 全球版本号

SVN的全局版本号和CVS的每个文件都独立维护一套版本号相比，是一个非常大的进步。在看似简单的全局版本号的背后，是Subversion提供对于事物处理的支持，每一个事物处理（即一次提交）都具有整个版本库全局唯一的版本号。
Git的版本号则更进一步，版本号是全球唯一的。Git 对于每一次提交，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，得到一个40位的十六进制字符串，Git将此字符串作为版本号。

•	使用哈希值作版本号的好处就是对于一个分布式的版本控制系统，每个人
每次提交后形成的版本号都不会出现重复。另一好处是保证数据的完整性，因为哈希值是根据内容或目录结构计算出来的，所以我们还可以据此来判断数据内容是否被篡改。

•	Git 的版本号简化：Git 可以使用从左面开始任意长度的字串作为简化版
本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，你也可以使用更短的版本号）。

###  stage

Git使用git fetch和git pull来完成远程更新任务，fetch操作只是将远程数据库的object拷贝到本地，然后更新remotes head的refs，git pull 的操作则是在git fetch的基础上对当前分支外加merge操作。 


         A            |      B         |      C
    working directory |  staging area  | git directory(repository)

从A不可直接到C，需先从A到B，称为stage files，然后再从B到C，称为commit

从C可直接到A，称为checkout the project

从B到A方向没有操作

git add 命令把文件加入到stage的监控范围
修改的文件不会自动更新到stage，每次修改文件必须重新更新到stage
git rm 命令标记删除文件

commit 只针对stage区域的改动进行提交

一个文件进行了修改，并git add到stage，
然后又进行了修改，则第二次修改并不会自动加入stage，
这时此文件的改动有两种状态：一是加入stage并在下次提交是入库的改动，另外的改动则不被提交，除非再次使用git add 加入


### 文件状态

我们可以从文件所处的位置来判断其状态：

* untracked
如果新建了文件，还未加入到版本库中，则是未追踪状态
* unmodified
如果取出后未进行修改则是未修改状态。
* modified
如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态，
* staged
如果作了修改并已放入暂存区域，就属于已暂存状态；
* page 23
如果是git目录中保存着的特定版本文件，就属于已提交状态；

### 分支和里程碑

在很多版本控制系统中，创建分支是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。

轻量级分支/里程碑的含义是，创建分支/里程碑的复杂度是o(1)，不会因为版本库的愈加庞大而变得缓慢。

里程碑是对某个历史提交所起的一个别名，作为历史的标记，是不应该被更改的。

Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1 哈希值）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（版本号外加一个换行符）那么简单，自然速度就很快了。

Git的分支实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。这和大多数版本控制系统形成了鲜明对比。

Git使用的标签有两种类型：
① 轻量级标签（lightweight）就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。
② 含附注标签（annotated）实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明。

一些常见的分支策略：
① 创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作。 
② 当进行高风险的工作时，创建一个试验性的分支，扔掉一个烂摊子总比收拾一个烂摊子好得多。 
③ 合并别人修改的时候，最好创建一个临时的分支用来合并，合并完成后再“fatch”到自己的分支。

### 分支操作命令
#### 查看分支
 git branch 
查看程序中已经存在的分支和当前分支 
#### 创建分支
  git branch 分支名称 
  git checout –b 分支名 
使用第一种方法，虽然创建了分支，但是不会将当前工作分支切换到新创建的分支上，因此，还需要命令“git checkout 分支名” 来切换， 而第二种方法不但创建了分支，还将当前工作分支切换到了该分支上。
#### 删除分支  git branch –D 
git branch –D 分支名可以删除分支，但是需要小心，删除后，发生在该分支的所有变化都无法恢复。 
#### 切换分支  git checkout 分支名 
如果分支已经存在，可以通过git checkout分支名来切换工作分支到该分支名 
#### 查看分支历史 git show branch 
调用该命令可以查看分支历史变化情况。
```
* [dev1] d2 
! [master] m2 
-- 
* [dev1] d2 
* [dev1^] d1 
* [dev1~2] d1 
+ [master] m2
```
在上述例子中， “--”之上的两行表示有两个分支dev1和master， 且dev分支上最后一次提交的日志是“d2”,master分支上最后一次提交的日志是”m2”。 
“--”之下的几行表示了分支演化的历史，
dev1表示发生在dev分支上的最后一次提交，
dev^表示发生在dev分支上的倒数第二次提交。
dev1~2表示发生在dev分支上的倒数第三次提交。 

#### 合并分支
git merge “some memo” 合并的目标分支 合并的来源分支。如： 
git merge master dev1~2 

#### 将远程分支合并到本地分支
git pull 合并的目标分支 合并的来源分支。 如：
git-pull . dev1^

合并有冲突时具体的冲突文件上会有冲突标记，在手动解决完冲突后就可以把此文件添加到索引(index)中去，用git commit命令来提交，就像平时修改了一个文件一样。 
$ git add file.txt
$ git commit

#### 快速向前合并

当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前"(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。

### 撤销

•	丢弃最新的一个提交：
$ git reset --hard HEAD^
•	丢弃最新的两个提交：
$ git reset --hard HEAD^^
•	丢弃某一提交之后的改动
$ git reset --hard COMMIT-ID

git commit –amend修改提交说明

### 授权

Git的授权模型只能实现非零即壹式的授权，要么拥有全部的写权限，要么没有写权限，要么拥有整个版本库的读权限，要么禁用。

有什么办法来解决授权的问题了？
1.	公司内部代码开放。即代码在公司内部，对项目组成员一视同仁的开放。
2.	公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。
3.	公司使用Subversion做集中式的版本控制，个人和/或团队使用 Git-svn。这样在无法改变公司版本控制策略时，程序员可以采用的变通之法。
4.	Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。

### git svn

git缺点
代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。

GIT-SVN 是一个 Perl 开发的 Git 插件。因为是 Perl 语言开发，因此还依赖 “Perl bindings for Subversion”。


