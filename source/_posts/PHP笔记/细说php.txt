php语言标记

	可以进出“PHP模式”

	共4种，其中标准类型和脚本类型总是可用的，简短类型和Asp类型需要在php配置文件中打开，因此移植性差，不推荐使用。

	标准类型：
		<?php
			echo "123" 
		?>
		推荐使用的php标准标记
		XML风格，如果php程序要嵌入XML或XHTML文档中，则使用此风格可保持符合标准
		如果?>之后就是整个脚本文件的结束，则?>可以不加，在文件被包含时，可以避免全局函数前面有空格而导致出错

	脚本类型：
		<script language="php">
			echo "123"
		</script>
		当使用的编辑器不支持标准风格标记时，可以使用此种风格

	简短类型：
		<?="1234"?>
		<? echo "123" ?>
		需要更改php的配置文件php.ini：short_open_tag=Off，改为On，修改后需重启Apache
		或者在编译时，加入--enable-short-tags
		SGML风格，会干扰XML文档的声明，不推荐使用

	Asp类型：
		<% echo "123" %>
		<%="123" %>
		需要更改php的配置文件php.ini：asp_tags=Off，改为On，修改后需重启Apache
		不推荐使用


指令分隔符：分号

	语句分为两种：结构定义语句和功能执行语句，功能执行语句后面一定要加分号.

	php代码的结束标记隐含表示了一个分号，因此一段php代码的最后一行可以不加分号
		<?php echo "111" ?>

	文件末尾的php代码结束标记可以不要，在使用include()和require()时更方便：
		1、在输出响应头信息时，就不会由于包含文件生成的不期望的空格而导致错误
		2、在使用输出缓冲时，就不会看到由包含文件生成的不期望的空格

程序注释

	支持c语言/**/、c++的//、unix shell的#风格的注释

	#和//	单行注释

		单行注释仅仅注释到行尾，或者，注释到php结束标记 ?>，无论先遇到哪个，都会跳出php模块，因此当注释的字符串中包含?>时注意，可能会得不到期望的结果
			<?php
			#echo "<?php echo time() ?>";?>aaa
		因此单行注释并不会注释掉?>，但却可以注释掉另一个php结束标记</script>
			<?php
			#echo "111";?>aaa<!--正常输出aaa，因注释到?>结束-->

			<?php//echo "111";?>bbb<!--正常输出bbb，因注释到?>结束-->

			<script language="php">//echo "111";</script>dd<!--无法输出dd，被注释掉了-->

	/* */	多行注释，遇到*/则结束，因此其中不能再包含多行注释
	/** */	文档注释

在程序中使用空白

	空格、tab、换行符

	PHP在输出时会自动删除结束符?>后的一个换行符，此设计主要是针对在一个页面中嵌入多段PHP代码或者包含了无实质性输出的PHP文件，也因此要在?>后输出换行的话，可以加一个空格，或者在最后的一个echo/print语句中加入一个换行。

语言结构和函数

	语言结构：
		是php的语言关键词，是php语法的一部分，就像if while一样
		可以有或没有参数
		可以有或没有返回值
		调用时可以有或没有括号

	php的语言结构比函数快：
		php中，函数执行时首先要被语言解析器分解为语言结构，因此函数比语言结构多了一层解析器解析。

	语言结构和函数的区别：
		速度比对应功能的函数快
		因语言结构只是语法的基本组成，不是函数，所以不能做回调函数、可变函数，但函数可以
		有些儿语言结构调用时可不使用括号，但函数必须有括号
		不能在php.ini中禁用，函数有些儿是内置，有些是扩展，则可以
		在错误处理上比较鲁棒，由于是语言关键词，所以不具备再处理的环节
			如使用isset()判断不存在的变量时并不会产生Notice错误，但函数直接使用未声明变量则会产生
				但传给函数引用变量时不会产生Notice错误
				<?php
					function test($param){
						echo $param;
					}

					test($a);  //notice错误
					test(&$b)  //没有

	下列都是语言结构而不是函数?个：
		echo()
		print()

		eval()
		list()
		array()

		isset()
		unset()	
		empty()

		require()
		?require_once()
		include()
		?include_once()

		die()
		exit()
		return()


变量的声明

	变量的声明
		使用一个美元符号后跟变量名来表示: $变量 = 值
		以字母或下划线开头，后面跟数字、字母或下划线
			这里的字母除了小写a-z和大写A-Z外，还包括ASCII码从127到255（0x7f-0xff）的字符，是一些乱七八糟的字符使用chr输出后也看不到
			因此可声明为php变量的字符个数为：小写字母26+大写字母26+数字10+下划线1+ASCII从127到255的129个=182个，其中常用的为63个，开头的为52个
			鉴于上述描述，php变量的正则可描述为'/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/'
			变量名中可以使用中文

	变量的赋值
		分为传值赋值和引用赋值两种
		默认总是为传值赋值
		将&符号加到要赋值的原变量前，即为引用赋值
			$a=&$b;
		只有有名字的变量才可以引用赋值：
			$a=&(10*18);	//错误，引用了没有名字的表达式
			$a=&test();	//错误

	变量的初始化
		php的变量不需要初始化，但未初始化的php变量会发出E_NOTICE错误，但是在向一个未初始化的数组附加单元时不会
			$str.="aaa";
			$int+=10;	
			$float+=1.11;
			echo ($bool?'true':'false');	//以上均会发生E_NOTICE错误
			$arr[]=11;			//这个不会
		未初始化php变量的值是其类型的默认值：字符串为空，布尔值为false，整型和浮点型为0，数组为空数组
		依赖未初始化变量的默认值可能会产生问题

	变量的生命周期和isset语言结构

		变量在使用之前，是不存在的，即还未创建到内存，使用isset判断则返回false
		变量在第一次使用时，则被自动创建到内存，同时获得了一个与应用环境对应的类型，若这时没有指定变量值，则返回类型的默认值（不同于其他语言如C，不指定变量值时，其默认值是指向的内存空间中的垃圾值），这时isset返回true
		销毁的变量的方法：设置变量值为null $a=null;
				  使用unset方法 unset($a);
		无论使用哪种方法，销毁变量后isset返回false
		还有一种特殊情况，变量已被创建到内存，但其值为null，则isset也返回false

        isset语言结构
            判断一个变量是否存在 同时 变量存在时其值是否为null
            只能用于判断变量，不能传表达式、函数等
            参数的个数不限，当多个参数时，从左到右分别判断各参数的值(遇到false就停止)，进行&&运算，返回整个isset的值

        总结isset：
            变量已被创建到内存且其值不为null时返回true
		

	empty语言结构

		未创建的变量使用empty判断不会发生notice错误，返回值为true
		变量已创建，当其值为类型的默认值时，返回值为true

        访问一个不存在的数组元素时，is_null等函数会发生错误，而语言结构isset和empty则不会，使用isset和empty对数组和元素检测

            <?php
            $item = array(); 
                //Now isset($item) returns true. But isset($item['unicorn']) is false.
                //empty($item) is true, and so is empty($item['unicorn']

            $item['unicorn'] = '';
                //Now isset($item['unicorn']) is true. And empty($item) is false. 
                //But empty($item['unicorn']) is still true;

            $item['unicorn'] = 'Pink unicorn';
                //isset($item['unicorn']) is still true. And empty($item) is still false. 
                //But now empty($item['unicorn']) is false;
            ?>

        总结empty：
            变量已被创建到内存且其值不为类型默认值时返回true


	php是弱类型语言，变量的类型由存储的值确定
		

		变量的声明和使用都需要$
		不能使用php的运算符号
		可以使用系统关键字作为变量名，如$if="aa"; $self="aa";  $parent="aa";但$this是一个特殊的变量，不可以被赋值
		变量和常量区分大小写，但其他不区分，如函数echo和Echo是一样的

	检测变量是否初始化
		使用isset()语言结构

可变变量

	一个变量的变量名可以动态设置和使用，如

	<?php
		$one = "xxx";
		$two = "one";
		$three = "two";
		$four = "three";

		echo $four;
		echo $$four;
		echo $$$four;
		echo $$$$four;

变量的引用赋值

	使用&符号

	<?php
		$one = "10";
		$two = &$one;


变量的类型

	PHP虽是弱类型语言，但也有变量类型概念，共有8种类型，4种标量，2种特殊类型，2种复合类型

	4种标量：
		整型 int integer
		浮点型 float double real
		布尔型 bool boolean
		字符串 string
	2种复合类型
		数组 array
		对象 object
	2种特殊类型
		资源类型 resource
		NULL类型
			表示变量没有值
			只有一个值null，不区分大小写
			判断一个变量值是否为null时，$var===null比is_null($var)快
			下列情况下，一个变量被认为是null
				未被赋值
				被赋值为null
				被unset()
			空数组和null
				空数组和null使用==进行比较时，空数组会被转为null，结果返回true
				空数组和null使用===比较时，因类型不同，一个为数组类型一个为NULL类型，返回false
				空数组使用is_null判断时，is_null只判断是不是null值，不是返回false
			变量赋值为null和被unset()的区别：
				当一个变量$a被引用传值给变量$b时
					unset()其中任意一个变量，不影响另一个变量
						$a=123;
						$b=&$a;
						unset($a); 	//只影响$a
						var_dump($a);
						var-dump($b);
					将任意一个变量赋值为null，则同时影响另一个变量
						$a=123;
						$b=&$a;
						$a=null; 	//同时影响$a和$b
						var_dump($a);
						var_dump($b);
				被unset()后的变量会报Undefined Variable错误，但赋值为null后的变量则不会，如下列中的is_null和var_dump都是在判断不存在变量时会报错
					$a=123;
					$a=null;
					echo is_null($a);
					var_dump($a);
                unset()可理解为将变量名从内存中抹去，而赋值为null则是将变量名对应的真实变量内容置为NULL值
				
	关于处理未定义变量时是否报错：
		语言结构更容易忽略错误，因此语言结构处理不存在的变量并不报错，如isset,empty；但函数则报错，如is_null,var_dump

	is_null和isset
		isset为语言结构，is_null为函数，因语言结构更容易忽略错误，因此isset不存在的变量并不报错，但is_null则报错（empty为语言结构也不报错var_dump为函数也报错)
		is_null判断的是表达式是否为null类型的null值，参数可以为变量或函数或表达式
		isset判断的是变量是否定义或其值是否为null
		is_null始终恰恰好是isset的相反值（只是在遇到unset的变量时is_null会报一个Notice错误）
			<?php

			$quirks = array(null, true, false, 0, 1, '', "\0", "unset");

			foreach($quirks as $var) {
			    if ($var === "unset") unset($var);

			    echo is_null($var) ? 1 : 0;
			    echo isset($var) ? 1 : 0;
			    echo "<br>";
			}

    使用==松散比较时，可转换为null的值 ：false,0,Null,array(),"",没初始化的变量,unset后的变量，赋值为null后的变量,无属性的对象
    使用==松散比较时，可转换为empty的值：false,0,Null,array(),"",没初始化的变量,unset后的变量，赋值为null后的变量,无属性的对象,"0"

	NULL 字节（"\0"）并不等同于 PHP 的 NULL 常数

	is_null
		注意字符串"0"，在empty("0")中返回true，在if("0")的逻辑判断中返回false
		判断一个未定义变量时会报错，但判断值被设置为null的变量时不报错
			is_null($a); //报错
			$b=null;
			is_null($b); //不报错


	var_dump(变量或值);	既可以查看变量或数据的类型，又可以查看值


		<?php

			$var = 10;

			echo "<pre>";
			echo var_dump($var);
			echo "</pre>";

			echo "----------------<br>"

各种类型变量的声明

	<?php
		$int = 10;	//十进制声明
		$int = 045;	//以0开头的表示8进制声明
		$int = 0xff;	//以0x或0X开头的表示16进制声明

		$float = 10;
		$float = 3.14E5
		$float = 3.14E+5
		$float = 3.14E-5	//E也可以小写

		//布尔值的声明，以下都是false的情况
		$bool = false;	//true为真
		$bool = 0;	//相反，非0的数为真
		$bool = 0.000;	//相反，有非0的数出现
		$bool = "";	//相反，非空非0字符串为真
		$bool = "0";//相反，非空非0字符串为真
		$bool = " ";//相反，非空非0字符串为真
		$bool = null;	//相反，非空代表真
		$bool = array();	//相反，非空数组为真
---------------------------------------------------------------------------------------------------------------------------2014-03-08
		//字符串有多种声明方法
		//1、单引号、双引号和界定符都可以声明字符串
		//2、声明的字符串没有长度限制
		//3、双引号字符串中，可以直接解析变量和使用转义字符
		//4、双引号中不能再使用双引号，单引号中不能再使用单引号
		//5、单引号字符串中，不可以解析变量，只能转义单引号本身和转义字符\本身
		//6、双引号中解析变量时，
			$var = 100;
			$str = "aa$varbbdddd";
		     解析失败，因变量$var后无明显的断点符号，如空格，加号，逗号等，例如：
			$str = "aa$var bbdddd";
		     则成功，标准方法应该是使用大括号将变量括起来，$符号可括可不括，例如：
			$str = "aa{$var}bbdddd${var}bbdddd";
		//7、虽然双引号比单引号功能强，但最好使用单引号，原因是双引号的变量解析和转义或消耗相对多的资源
		//8、大量的字符串，使用定界符声明，格式为
		$str=<<<hello
	这里是任意字符串
	asdfdfsdfsdfsadfsdf
hello;
		以<<<开头，其中hello为自定义字符，第一个hello后不能有任何字符，第二个hello必须顶格写，前面不能有任何字符。
		//9、定界符中可以任意使用双引号、单引号，同时可以解析变量和转义字符。


数据类型之间的转换
	分为强制转换和自动转换，最常用为自动转换

	强制转换：
		1、setType(变量，类型); 
			//类型有int或integer,float,double,real,bool或boolean,string,array,object
			//这个函数将原变量的类型改变

		2、在赋值前使用(类型)的形式，不会改变原变量的类型
		$str = "100.112ab";
		$var = (int)$str;	

		3、使用一些儿有针对性的转换函数
		$变量=intval(变量或值);
		$变量=floatval(变量或值);
		$变量=stringval(变量或值);

		注意：整型在内存中占4个字节，最大范围为2.147e9
			浮点型在内存中占8个字节

	自动转换
		$a = 10;
		$b = 100.11;
		$c = "23asd";
		$d = true;
		$sum = $a+$b+$c+d;
		echo var_dump($sum);
与变量和类型有关的一些儿常用函数

	isset();
	empty();
	unset();

	getType();
	setType();
	
	变量类型测试函数
	is_bool();
	is_int() is_integer() is_long()
	is_string();
	is_float() is_double() is_real()
	is_array()
	is_object()
	is_resource()
	is_null()

	is_scalar()
	is_numeric()
	is_callable()

常量的声明与使用

	define("常量名",值);

	常量是一个简单值的标示符
	常量不能改变其值，也不能使用unset()取消
	常量可以不用理会变量范围的规则而在任何地方都可以定义和访问
	常量在声明和使用时都不使用$
	常量名称习惯都使用大写
	常量的值只能用标量类型（int,float,bool,string）
	常量一定要在声明时就给值
	defined("常量"); 检测某个常量是否已定义

系统的预定义常量和魔术常量

	所谓魔术，即会根据环境变化的
	魔术常量以__开头，如__FILE__、__LINE__

运算符

	算术运算符	+ - * / % ++ --
		%和/的除数不能为0
		%  	会将运算符两边转换为整型后再进行运算
			使用目的：整除运算 和 控制一个数的范围
		++ --	j=i++，运算符在后，表示先使用变量赋值再进行加运算
			j=++i，运算符在前，表示先进行加运算，再将结果赋值

	字符串运算符	.
		可以和4种标量进行连接

	赋值运算符	= += -= *= /= %= .=
		$a.="abc";即$a=$a."abc"; 用于字符串拼接操作

	比较运算符	> < >= <= == === !=或<> !==
		也称为条件运算符或关系运算符，结果只有一种就是布尔值
		=== 比较时不仅要求内容相同，也要求类型相同
		!== 内容或类型不同时都返回真

	逻辑运算符	& | &&或and ||或or !或not
		&和|，无论前面的条件真假，后面的条件判断都会执行
		&&和||，则会根据前面的判断结果，来确定是否需判断后面的条件
	位运算符	& | ^ ~ << >> >>>
		可以和赋值运算符=结合使用，如$a &= $b; 即 $a = $a & $b;
		^ 按位异或，相同为0，不同位1
			可以使用异或交换两个数字的值
				<?PHP
				$a=5;
				$b=3;

				//Please mind the order of these, as it's important for the outcome.

				$a^=$b;
				$b^=$a;
				$a^=$b;

				echo $a.PHP_EOL.$b;

			上面的方法也可以用来交换两个字符串的值，但字符串的长度最好相等
			不能用于数组和对象，但可以通过串行化函数serialize后再使用，然后再反串行化unserialize还原

		~ 按位取反，$c =~$a;
		>> << 右移 左移 $c = $c >> 2;
		>>> 无符号右移，无论最高的符号位是0还是1，都补0

	其他运算符	?:  ``  @ => -> :: & $
		`` 命令执行符，将其中的字符串作为系统命令执行，并返回执行结果，如$str=`ipconfig -all`;echo $str;
		@  错误控制符，用于屏蔽产生的错误和警告，如@getType();


流程控制

	一、顺序结构
	二、分支结构--条件结构--选择结构
		1、单路分支
			if(条件)
				一条代码；

			if(条件){
				代码段；
				代码段；
			}
		2、双路分支
			if(条件)
				一条代码;
			else
				一条代码;

			if(条件){
				代码段；
				代码段；
			}else{
				代码段；
				代码段；
			}
		3、多路分支
			if(条件){
				代码段；
				代码段；
			}else if{
				代码段；
				代码段；
			}else if{
				代码段；
				代码段；
			}else{
				代码段；
				代码段；
			}

			switch(变量){		//这里应该只能用整型和字符串
				case 结果1:
					代码段;
					break;
				case 结果2222:
				case 结果222:
				case 结果22:
				case 结果2:
					代码段;
					break;	//break跳出了switch，也可以利用break匹配多个条件
				case 结果3:
					代码段;
					break;
				default:	//变量没有匹配，则执行default，可选
					代码段;
			}

			判断一段范围使用else if，判断准确值匹配使用switch

		4、嵌套分支
			if(条件){

				if(条件){
					代码段；
					代码段；
				}else{
					代码段；
					代码段；
			}else{
				代码段；
				代码段；
			}
			
	三、循环结构

		计数循环for

			for(初始化;条件表达式;增量){

			增量	循环体;

			}
		
			初始化和增量也可以用多个条件，如：

			for($i=0,$j=0;$i<100 && $j<100;$i++,$j++){

			}

		条件循环while	do while

			while(表达式){
				循环体;
			}


			do{

				循环体;

			}while(表达式);   --->注意这里的分号

	四、几个和循环有关的语句

		break;		跳出当前层循环
				
		break x;	跳出x层循环,x为数字

		continue;	结束本次循环，开始下一次循环

		continue x;	结束x层循环，开始新循环

		exit;

		return;

函数

	1、function 函数名(参数列表){

		函数体；
		返回值；

	   }

	参数列表和返回值可省略
	没有返回值的函数也称为过程
	函数执行到return语句即返回了函数调用处
	php无名称空间，所以函数不能重名，包括和系统函数

	2、函数定义时也可为参数设置默认值：
	function test($a,$b=10,$c=22){

	}
	有默认值的参数调用时不传值则会使用默认值，不会发生错误：
	test(1);
	test(1,2);
	test(1,2,3);
	?无默认值的参数可称为必填值，有默认值的称为可选值，是否必填值一定不能在可选择后面？测试证明？

	3、一个参数也没有的函数，也表示可以传任意多个参数
	function test(){
		$args=func_get_args();
		echo count($args);

		//另一种方法
		for($i=0;$i<func_num_args();$i++){
			echo func_get_arg($i);
		}
	}
	test(1,2,3,4,5);

	4、定义回调函数
	function test($x,$y){

	}

	function test2($a,$b,$fun){
		return $a+$b+$fun($a,$b);
	}

	test2(1,2,"test");

系统函数使用时的分类

	1、常规函数，如
		bool copy(string source,string dest)
	2、参数带有mixed的函数，mixed表示可以传任何类型的数据
		bool chown(string filename,mixed user)
	3、参数带有&符号的函数，表示引用赋值，这个参数不能传值，只能传变量的引用
		bool arsort(array &array[,int sort_flags])
	4、带有[]的函数，表示参数可选，不传值时使用默认值
		bool arsort(array &array[,int sort_flags])
	5、参数带有...的函数，...表示可以传任意个参数
		int array_unshift(array &array,mixed var [,mixed ...])
	6、参数带有callback表示回调函数，即在调用函数时我们需要再传一个函数进去（函数名或函数名字符串），这个传进去的函数会在调用的函数中被调用
		array array_filter(array input [,callback callback])

		示例：
		$a = array(1,2,-3,4,-5,6,-7,8,9);

		function test1($n){
			if($n%2==0)
				return true;
			else
				return false;
		}
		
		function test2($n){
			if($n>0)
				return true;
			else
				return false;
		}

		print_r(array_filter($a,test1));

		print_r(array_filter($a,test2));

变量范围

	局部变量
		在函数中声明，只能在函数中调用
		函数的形参是局部变量

	全局变量
		在函数外声明，在变量声明以后的所以代码中均可以使用(即使变量是在while循环中)，包括函数和{}中
		因为php变量的声明和使用都是用$后连上变量名，所以在php中使用全局变量要通过global关键字将全局变量包含到函数中
		$a = 10;
		function test(){
			echo $a;	//函数的局部变量
			global $a;	//使用global关键字后，后面的$a才是全局变量
			echo $a+=10;
		}
	
	静态变量
		静态变量只能声明在函数和类中，不能在全局声明
		使用static声明静态变量
		静态变量在函数多次调用时共用一个，只在第一次调用时声明到内存，以后再调用则直接使用
		静态变量即不在堆内存，也不再栈内存，保存在静态代码段中	
		function test(){
			static $a=0;
			$a++;
			echo $a;
		}	

		test();
		test();

变量函数
	有一个变量$var，其值为"hello"，即$var="hello"，如果在使用变量$var时，后面加上了括号，即$var()，则php将寻找与变量值同名的函数。
	function one($a,$b){
	}

	function two($a,$b){
	}

	if(true){
		$var="one"; 	//也可写成$var=one;
	}else{
		$var="two";
	}

	echo $var(3,4);


内部函数：php可以在函数内部再声明函数，目的就是在函数的内部调用，来帮助外部函数完成一些儿子功能。

	function demo(){
	
		function fun1(){

		}

		function fun2(){

		}
	}

递归函数：在自己内部调用自己的函数

	function demo($num){
		echo $num."<br>";

		if($num>0)
			demo($num-1);
		else
			echo "------------";

		echo $num."<br>";
	}

	demo(10);

	----------------------------------

	function total($dirname,&$dirnum,&$filenum){

		$dir = opendir($dirname);
		readdir($dir);
		readdir($dir);
		while($filename=readdir($dir)){
			$newfile=$dirname."/".$filename;
			if(is_dir($newfilename)){
				total($newfile,$dirnum,$filenum);
				$dirnum++;
			}else{
				$filenum++;
			}
		}
		closedir();
	}

	$dirnum=0;
	$filenum=0;
	total("c:/appserv/www/phpmyadmin",$dirnum,$filenum);


重用函数（使用自己定义的函数库）

	require：用于静态包含
	include:用于动态包含
	require_once:相对于require，可防止重复包含一个文件，但效率相对较低
	include_once

	require "header.inc.php";

	if($className=="Action")
		include "action/".$className.".php";
	else
		include "public/".$className.".php";
		
	require "footer.inc.php";


系统指令

	php的系统指令有两种写法，如：
		include "file.inc.php";
		include("file.inc.php");

		echo "haha";
		echo("haha");

数组概述
	1、数组的本质是声明和操作一批变量，成批处理
	2、数组是php支持的8种数据类型中的复合类型
	3、数组可以存储任意长度的数据，也可以存储任意类型的数据
	4、php的数组可以完成其他语言中很多数据结构的功能，如链表、队列、栈、集合类等。

数组的分类：
	1、一维数组，二维数组，三维数组，多维数组
	2、php数组又可分为索引数组和关联数组
		索引数组：下标使用整数做为索引
		关联数组：下标使用字符串作为索引

数组多种声明方式：
	1、直接为数组元素赋值
		$user[0]=1;
		$user[1]="zhangsan";
		$user[2]=10;
		echo "<pre>";
		echo print_r($user);
		echo "</pre>";

		上面的索引下标也可以不写，即：
		$user[]=1;
		$user[]="zhangsan";
		$user[]=10;
		也会自动从0开始索引，结果和上面的效果相同
		如果给出下标，下一个的索引是最大索引值加1，如
		$user[]=1;		--->这里索引是0
		$user[]="zhangsan";	--->这里索引是1
		$user[5]=10;
		$user[]="boy";	--->这里索引是6

		使用字符串下标：
		$user["num"]=1;
		$user["name"]="zhangsan";
		$user["age"]=10;
		$user["sex"]="boy";

		但将索引数组和关联数组混合声明时，关联数组的声明不影响索引下标的声明
		$user["num"]=1;
		$user["name"]="zhangsan";
		$user[1]=10;
		$user["sex"]="boy";
		
	2、使用array()函数
		1、默认是索引数组
			$user=array(1,"zhangsan",10,"boy");
		2、声明关联数组需使用=>指定键值对
			$user=array("id"=>1,"name"=>"zhangsan",12=>10,"boy");
			其中前两项声明为了关联数组，后两项声明为了索引数组，且指定了下标从12开始

		3、声明二维、三维数组
			$user=array(array(1,"zhangsan",10,"boy"),array(1,"lisi",10,"boy"),array(1,"wangwu",10,"boy"));

			$info=array(
					"user"=>array(
						array(1,"zhangsan",10,"boy"),
						array(2,"lisi",10,"boy"),
						array(3,"wangwu",10,"boy"),
					),
					"score"=>array(
						array(1,"zhangsan",10,"boy"),
						array(2,"lisi",10,"boy"),
						array(3,"wangwu",10,"boy"),
					),
					"class"=>array(
						array(1,"zhangsan",10,"boy"),
						array(2,"lisi",10,"boy"),
						array(3,"wangwu",10,"boy"),
					)
				);
	3、使用其他的函数声明
		file();


数组的多种遍历方式：

	1、使用for语句
		数组必须是索引数组，且下标是连续的，但php下标可不连续，且可能是关联数组，故这种方式不是php首先方式

		$user=array(1,"zhangsan",10,"boy");
		for($i=0;$i<count($user);$i++){
			echo "\$user[{$i}]=".$user[i]."<br>";
		};
		
	2、使用foreach语句

		foreach(数组变量 as 变量值){
			//循环体
		}

		循环次数由数组的元素个数决定
		每一次循环都会将数组中元素分别赋值给后面变量

		foreach($user as $var){
			echo $var."<br>";
		}

		foreach循环时也可获得下标

		foreach(数组变量 as 下标变量=>变量值){
			//循环体
		}

		foreach($user as $key=>$var){
			echo $key."-------".$var."<br>";
		}

	3、使用while() list() each()组合

		each()函数
			1、需要一个数组做参数
			2、返回值也是一个数组
			3、返回来的数组有0,1,key,value四个下标
				0和key下标是当前数组元素的键
				1和value下标是当前数组元素的值
			4、默认当前元素是第一个元素，执行一次就向后移动一个元素，到最后取不到元素时返回false

			$user=array("id"=1,"name"=>"zhangsan","age"=>10,"sex"=>"boy");
			while($arr=each($user)){
				echo $arr[0]."=>".$arr[1]."<br>";
				echo $arr["key"]."=>".$arr["value"]."<br>";
			}

		list()函数
			1、需要将数组赋值给这个函数
			2、数组中的元素个数，要和list()函数中的参数个数相同
			3、数组中的每个元素值会按索引顺序赋值给list函数中的每个参数，list将每个参数转为变量
			4、只能接受索引数组

			list($name,,$sex)=array("zhangsan",10,"boy");
			echo $name."----".$sex;

		list()和each()组合使用
			
			$user=array("id"=>1,"name"=>"zhangsan","age"=>10,"sex"=>"boy");

			while(list($key,$value)=each($user)){
				echo $key."=>".$value."<br>";
			}

		数组内部指针控制函数
			
			next(数组);	//移到下一个元素
			prev(数组);
			reset(数组);	//移到第一个元素
			end(数组);
			
			current(数组);	//获取当前元素value
			key(数组);	//获取当前元素key


php中预定义的超全局数组

	1、包含了来自web服务器端、客户端、运行环境和用户输入的数据
	2、在全局范围内可以直接使用
	3、用户不能自定义这些儿数组
	4、在函数内不用使用global关键词导入即可直接使用

	$_GET
		经由url请求提交至服务器脚本的变量，长度限制8092字节
		<a href="demo.php?username=ssl&age=10&sex=boy">go</a>
		可以直接使用同名的变量接收，即
		echo $username;
		echo $age;
		echo $sex;
		但一般为安全起见，这个选项在php配置文件中是关掉的，建议使用$_GET
		echo $_GET["username"];
		echo $_GET["age"];
		echo $_GET["sex"];
	$_POST
		经由HTTP POST方法至服务器脚本的变量
	$_COOKIE
		
	$_REQUEST 
		经由GET、POST和COOKIE机制提交到脚本的变量，当不确定用户提交数据的机制时使用此数组
	$_FILES
		经由HTTP POST上传文件提交到脚本的变量
	$_SESSION

	$_ENV
		执行环境提交到脚本的变量
	$_SERVER
		此数组中保存的变量由web服务器设定 或 直接和当前脚本的执行环境相关联
	$GLOBALS
		当前脚本所有有效地变量，包括所有超全局数组如$_GET,$_POST...和当前脚本文件中用户定义的全局变量如$a,$b，键名也分别为超全局数组变量名称和全局变量名，也因此在函数中，访问全局变量$a，除了可以使用global $a;包含后使用外，还可以直接使用$GLOBALS["a"]使用。


数组的相关处理函数：

	一、数组键值操作函数
		1、array_values()
		2、array_keys()
		3、in_array()
		4、array_key_exists()
		5、array_flip()
		6、array_reverse()

	二、统计数组元素的个数和唯一性的函数
		1、count(); sizeof();
		2、array_count_values();
		3、array_unique();

	三、使用回调函数处理数组的函数
		1、array_filter();
		2、array_walk();
		3、array_map();

	四、数组的排序函数
		1、根据元素值对数组排序（忽略键值）
			sort();rsort();
		2、根据键名对数组排序
			ksort(); krsort();
		3、根据元素值对数组排序（保留键值）
			asort(); arsort();
		4、根据自然排序法对数组排序，字母按a到z，数字按1到9
			natsort(); natcasesort();
		5、根据用户自定义规则对数组排序
			usort(); uasort(); uksort();
		6、多维数组排序
			array_multisort();

	五、数组的拆分、合并、分解、结合的数组函数
		1、array_slice();
		2、array_splice();
		3、array_combine();
		4、array_merge();
		5、array_intersect();
		6、array_diff();
		x、+ 比较下面的输出
			$a1=array(1,2,3,4);
			$a2=array(5,6,7,8);
			$a3=$a1+$a2;
			print_r($a3);

			$a1=array(1,2,3,4);
			$a2=array(10=>5,6,7,8);
			$a3=$a1+$a2;
			print_r($a3);
	
	六、数组与数据结构的函数
		1、使用数组实现堆栈
			入栈：$arr[]="a"; 和这句效果相同，但比这句效率高array_push($arr,"a");
			出栈：$value=array_pop($arr); 注意：$arr[0]只是读取不是出栈
		2、使用数组实现队列
			array_unshift($arr,"c","d");
			$value=array_shift($arr);
		3，使用数组实现链表
			unset($arr[5]);	

	七、其他与数据操作有关的函数
		1、array_rand();
		2、shuffle();
		3、array_sum();
		4、range();	//除了是数字还可以是字母，如range("a","k");


面向对象概述
		面向对象和面向过程的区别
			最小单位：函数
			最小单位：对象
		对象就是一个实体，一个东西
			成员属性==变量，定义对象外观和状态
			成员方法==函数，定义对象功能

类的声明
	[修饰类的关键字] class 类名{


	}

	1、一个文件只保存一个类
	2、文件名包含类名：类名.class.php，还可方便自动加载 
	3、成员属性和成员方法按驼峰命名法，第一个单词首字母小写，以后每个单词首字母大写
	   类名每个单词首字母大写 常量所有字母大写
	4、在类中声明成员属性时，前面必须有修饰词，当不知道用哪个时，就用var

类的实例化
	1、$对象实例=new 类名;
	2、对象中的成员必须通过对象实例来访问，使用符号->
		echo 对象实例->成员属性;
		echo 对象实例->成员方法;
		对象实例->成员属性=新值;
	3、对象内部成员的访问
		使用$this关键字，代表当前的对象实例

面向对象的构造与析构方法：

	构造方法：作用是为成员属性初始化
		  php4中和类名相同的方法就是构造方法，和正常的方法相同，也可以传参数，并为参数设默认值
		  php5中构造方法选择魔术方法__construct()，优点是在修改类名时不用改变构造方法名
		  php4和php5的两种构造方法可以共存，共存的必要是为了兼容php的不同版本

		class Person{
		
			var $name;
			var $age;
			var $sex;

			function Person($name,$age,$sex){
				$this->name=$name;	---->注意这里的name和$name，分别代表成员属性和构造方法的参数
				$this->age=$age;
				$this->sex=$sex;
			}
		}

		$p1=new Person("zhangsan",11,"boy");

	析构方法：对象释放之前最后一个自动调用的方法
		  作用是关闭一些儿资源，做一些儿清理工作，并非释放对象
		  java和PHP都是用垃圾回收器，而c++手动释放；
		  __destruct()
		  因为对象引用是保存在栈内存中的，而栈是后进先出，所以在系统自动释放对象时，是最后创建的对象最先释放
		  可以使用 $对象引用=null; 来提前手动释放对象
	
数据段、栈内存、堆内存、代码段
	栈内存：空间小速度快，存储固定空间的数据，如整型变量
	堆内存：空间大速度慢，存储长度不固定或比较大的数据，如字符串
	代码段：保存程序结构的，包括函数和方法等。

魔术方法：
	是为了完成某功能自动调用的
	在类中写出了某个魔术方法，这个方法对应的功能就会启用，不添加则不启用
	方法名称都是系统定义好的，不是自己定义的
	都是以__开头的，包括：
		__construct();
		__destruct();
		
		__set();
		__get();
		__isset();
		__unset();
		
		__clone();

		__call();

		__sleep();

		__wakeup();

		__toString();

		__autoload();

		......


面向对象特性：封装性

	如果一个变量需要在多个方法中使用，就将这个变量声明为成员属性，这样，可以直接在这个对象的所有方法中使用这个成员属性，相对于这个对象的全局变量。

	php中与asp的property let和property get类似的方法即下面魔术方法中的__set()和__get()，不同的是，asp的每个属性有一个对应的let和get，而php是所有属性共用一个__set()和__get()

	魔术方法：
		__set();
			直接设置私有成员属性值时，自动调用的方法
		__get();
			直接获取私有成员属性值时，自动调用的方法
		__isset();
			直接查看对象中私有属性是否存在时自动调用的方法
		__unset();
			直接删除对象中的私有属性时自动调用的方法

	public：类内部、子类、类外部均可以访问

	protected：只能在类内部和子类中访问

	private：私有的，用这个关键字修饰的成员，只能在对象内部访问。


面向对象特性：继承性

	一、类继承的应用
		c++属于多继承，即同一个类可以有多个父类
		php和java属于单继承，即同一个类只能有一个父类
		但不管是单继承还是多继承，都可以有多个子类
		使用extends关键字来继承父类
		class Student extends Person{

		}

	二、访问类型控制
		子类可以从父类继承所有内容，包括成员属性、成员方法、构造方法……使用方法和使用子类自己的成员一样，但私有成员除外，私有成员只能在所在类中调用
		封装时，让类内部可以使用，让子类也可以使用，但类外部不能使用，可以使用protected

	三、子类中重载父类的方法
		子类可以声明和父类相同的方法名，即子类覆盖了父类中相同的方法

		php的重载和java不同，java重载指的是方法名相同，当方法的参数类型或参数个数不同；但php是弱类型语言，无法确定参数类型，且有默认值的参数可不传值，也就无法确定调用时准确地参数个数，故无法实现java那样的重载。

		在子类中调用父类中被覆盖的方法，使用的是：父类名::方法名(); 或用 parent::方法名(); 可以避免父类改名时也要同时修改

		如果子类中有构造方法，父类中也有构造方法，一定要去调用一次父类中被覆盖的构造方法，否则父类很可能没有正确的初始化

		注意：子类中重载的方法，不能低于父类中的访问权限


常用关键字

	final
		1、final不能修饰成员属性（java中是使用final声明常量的，但php中声明常量是define和const）
		2、final只能修饰类和方法
		作用：
			使用final修饰的类，不能被子类继承
			使用final修饰的方法，不能被子类覆盖

	static
		1、可以修饰成员属性和成员方法，不能修饰类
		2、用static修饰的成员属性，可以被同一个类的所有对象共享
		3、静态的数据是保存在内存数据段中，也叫做初始化静态段
		4、静态的数据是在类被第一次加载时分配到内存中的，以后再用到类时，则直接从数据段中获取
		5、什么是类被加载？只要在程序中使用到这个类，即有这个类名出现？？不用创建对象？？
		6、静态的成员使用类名即可访问，不用创建对象 类名::静态成员; 在类中，self代表本类，可以使用self::静态成员;来访问。
		7、静态方法，不能访问非静态的成员。因为静态方法可通过类直接访问，这时没有对象存在，而非静态成员必须有对象存在才能访问。
		8、如果确定一个方法不用访问非静态成员，则可以声明为静态方法，好处是不用创建对象即可访问。

		思考：单态设计模式，一个类只能创建一个对象？

	const
		1、只能修饰成员属性
		2、类中声明常量属性使用const（define类外？）
		3、除声明方式不同外，其他规则和define一样，如一样没有$，字母全部大写等
			const HOST="www.ssl.com";
		4、访问方式和静态成员属性是一样的，在类外部通过 类名::常量 ,类内部通过  self::常量  的方式。
		5、常量一定要在声明时就给出值。


常用魔术方法

	__call()
		作用：在调用对象中不存在的方法时就会出现系统报错系统退出。用此函数可以处理此类不存在方法的错误调用。

		什么时候调用：在调用一个对象中不存在的方法时自动调用。
		参数1：被调用的不存在的方法的方法名
		参数2 ：调用方法时传的参数数组

		function __call($funcName,$args){

		}

	__toString()
		作用：用来快速获取对象字符串的最便捷方式
		什么时候调用：直接输出对象引用时调用

	__sleep()
		作用：可以将一个对象部分串行化

		      只要这个方法中返回一个数组，数组中有几个成员属性就序列化几个成员属性，如果不加这个方法，则所有成员都被序列化。
		什么时候调用：是在序列化时自动调用的方法

	serialize()
		参数是一个对象，返回的是串行化后的二进制串。

		对象串行化（序列化）：将一个对象转为二进制串

		1.将对象长时间存储在数据库或文件中
		2.将对象在多个php文件中传输

	unserialize()
		参数是对象的二进制串，返回的是对象

	__wakeup()
		作用：
		什么时候调用：是在反序列化时自动调用的方法
				也是对象重新诞生的一个过程，可以在反序列化后重新初始化对象

	__autoload()
		这是唯一一个不在类中添加的魔术方法，其他魔术方法都是在类中添加起作用。
		只要在页面中使用到一个类，只要用到类名就会自动将类名传给这个参数	

		require "one.class.php";
		require "two.class.php";
		require "three.class.php";
		可用下面的函数代替
		function __autoload($className){
			include "./".$className.".class.php";
		}

		$one=new One;
		$one->fun1();
		$two=new two;
		$one->fun1();
		$one=new One;
		$one->fun1();

	__clone()
		作用：只要一个对象一诞生，就要有初始化的动作，克隆对象时同样会触发同样地初始化动作，可以在__clone()方法中为克隆对象初始化，这时$this代表克隆对象，$that代表原本对象。

		什么时候调用：克隆对象时自动调用

		$p=new Person;
		$p1=clone($p);
		这时触发__clone()方法


抽象类、接口和面向对象特性：多态

	抽象类是一种特殊的类
	接口是一种特殊的抽象类
	多态需要使用到抽象类或接口

什么是抽象方法？

	如果一个类中的方法没有方法体，这个方法就是抽象方法，没有方法体是指连{}都没有而是直接使用分号结束，而不是{}中内容为空。

	function test(); //抽象方法

	function test(){ //这个不是没有方法体，而是方法体为空，不是抽象方法

	}

	如果一个方法是抽象方法，就必须使用abstract修饰，即

	abstract function test();

什么是抽象类？

	1、如果一个类中有一个方法是抽象的，则这个类就是抽象类
	2、如果一个类是抽象类，则这个类必须使用abstract修饰
		abstract class Demo{
			abstract function test();
		}
	3、说抽象类是一个特殊的类，就是因为抽象类中有抽象方法，其他和非抽象类相同，即可以声明成员属性、常量、非抽象方法。
	4、抽象类不能实例化对象


疑问：
	1、抽象方法没有方法体，做什么用？
	2、对象中的方法和属性都要通过对象访问（除了常量和静态变量和方法），而抽象类不能实例化对象，则抽象类中的成员不能直接访问

因此：
	要想使用抽象类，必须使用一个类去继承抽象类；但子类继承了抽象类中的抽象方法，子类也称为了抽象类，因此也无法创建对象；因此要想子类可以创建对象，子类就必须重载父类的抽象方法，给抽象方法加上方法体，使子类不再是抽象类。

总结：
	抽象方法中的方法没有方法体，但子类必须实现这个方法。因此抽象类就是在定义一些儿规范，让子类按规范去实现自己的功能。目的就是在并行开发程序模块时不用互相等待，在全部开发完成后，又可以按预定设计整合到一起。

抽象类可多重继承，但任意一层类没有声明为abstract class，就要实现其上的所有层类中定义的抽象方法

abstract class Animal{

    abstract function move();
}

abstract class Bird extends Animal{


    abstract function eat();
}

class XiQue extends Bird{

    public function move(){
    
    }
    public function eat(){
        return 'wahaha'; 
    }
}

$a = new XiQue();
echo $a->eat();

接口==================

	接口是一种特殊的抽象类，接口和抽象类的作用一样

	因为php是单继承的，子类在继承抽象类后，就不能再去继承其他类了

	因此如果既想实现一些儿规范，又想继承一个非抽象类，就要使用接口

	接口和抽象类的对比：

		1、作用相同，都不能创建对象，都需要子类去实现
		2、接口的声明和抽象类不一样
			interface 接口名{

			}
		3、接口被实现的方式不一样
			class Test implements Demo{

			}
		4、接口中的所有方法必须是抽象方法，只能声明抽象方法，不用使用abstract修饰
		5、接口中的成员属性，只能声明常量，不能声明变量
		6、接口中的成员访问权限，都必须是public，抽象类中最低的权限是protected
		7、如果想让子类可以创建对象，则必须实现接口中的全部抽象方法，可以让抽象类去实现接口中的部分方法
		8、接口还可以继承接口，类只能被继承，而接口既可以被继承（被接口继承，不能被类），又可以被实现，如何区分是实现还是继承：主要是看子类是否有修改父接口的行为，即是否重写了父接口的方法。
			类     实现 接口 全部方法  使用implements
			抽象类 实现 接口 部分方法  使用implements
			接口   继承 接口           使用extends

                interface Usb{

                    function insert();

                    function loose();

                }

                abstract class Pc implements Usb{

                    function insert(){
                        return "inseting...."; 
                    }
                }

                class lenovo extends Pc{

                    function loose(){}
                }

                $pc = new lenovo();

                echo $pc->insert();

		9、一个类可以去实现多个接口(按多个规范去开发子类)，接口直接用逗号分隔
			class Test implements Demo2,Demo3,Demo4{

			}

		10、一个类可以在继承一个类的同时，实现一个或多个接口，顺序是先继承后实现，即
			class Test extends Demo1 implements Demo2
		11、使用implements的目的：
			可以实现多个接口，而extends只能继承一个类
			还可以继承一个类

面向对象特性：多态
	多态是面向对象设计的重要特性，它展现了动态绑定的功能，也称为“同名异式”。多态的功能可让软件在开发和维护时，达到充分的延伸性。事实上，多态最直接的定义就是让具有继承关系的不同对象，可以对相同名称的成员函数调用，产生不同的反应效果。


字符串处理函数特点：

	特点1、其他类型的数据用在字符串处理函数中，会自动将其转为字符串处理，如
	echo substr('abcdef';,2,3);
	echo substr(1234567,2,3);

	特点2、可以将字符串视为数组，当做字符集合来看待
	$str = "abcdefg";
	echo $str[2];	//避免和数组字符串混淆，改为下面的写法
	echo $str{2};

	echo $str{0}.$str{1};

	特点3、在PHP中所有字符串处理函数，都不是在原字符串上修改，而是返回一个新格式化后的字符串。

PHP中内置的字符串处理函数

	1、常用的字符串输出函数
		echo
			不加括号也可多个参数：echo "111","222","333";
			加括号只能一个参数：echo "111";
		print
			成功返回1，失败返回0
		die

			exit的别名

			fopen("11.php","r") or die("文件打开失败");
			echo "文件打开成功";

			exit(0); 0到254
		printf
			把字符串格式化字符串

			%%
			%b
			%c
			%d
			%f
			%o
			%x
			%s

			$str="100.123456abc";
			printf("%.2f-------%'_-20s--------%'_20s",$str,$str,$str);
		sprintf
			返回格式化的字符串

	2、常用的字符串格式化函数

		ltrim();
			删除空白，不仅仅是空格
			$str="   abc   ";
			echo strlen($str)."<br>";
			echo strlen(rtrim($str))."<br>";

			第二个参数指定要过滤的字符，即默认是空白，但自己可指定
			$str="123this is a test ...";
			echo ltrim($str,"0..9");
			echo ltrim($str,"0..9 .");

		rtrim();
		trim();
		str_pad();
			补充字符串

			参数1：往哪个字符串上补充
			参数2：补充的字符个数
			参数3：补充的字符
			参数4：补充的位置，左、右、两边

			$str="AAAA";
			echo str_pad($str,10,"-+",STR_PAD_LEFT);
			echo str_pad($str,10,"-+",STR_PAD_RIGHT);
			echo str_pad($str,10,"-+",STR_PAD_BOTH);



		strtolower();
		strtoupper();
		ucfirst();
			每句话头字母转为大写
		ucword();
			每个单词头字母转为大写



		nl2br();
			将文本的换行转换为html的<br>
		htmlentities();
		htmlspecialchars();
			将特殊字符转为html的实体，字符包括双引号、单引号、&号、左右尖括号
		stripslashes();
			将转义字符\去除并返回字符串
		strip_tags();
			从字符串中去除HTML和PHP标记，第二个参数指定你想保留的标签 



		number_format();
			参数1：要格式化的数字
			参数2：保留的小数位数
			参数3：小数点样式
			参数4：千分位样式
		strrev();
			反转字符串
		md5();
		md5_file();
			对整个文件md5加密

	3、字符串比较函数

		按字节顺序比较，即ASCII码比较
		strcmp();
			第一个参数和第二个参数比较
			相等 返回0
			大于 返回1
			小于 返回-1
		strcasecmp();

		按自然数排序
		strnatcmp();
			"1","2","10","12"
			上面为自然数
			而ascii码为
			"1","10","12","2"

正则表达式概述

	1、正则表达式是描述字符串排列模式的一种自定义语法规则
	2、可以使用字符串函数完成的任务则不要用正则表达式，一些儿复杂的操作则适合使用正则。
	3、正则表达式也称为模式表达式
	4、正则表达式是使用一些儿特殊字符，通过构建具有特定规则的模式，与输入字符串比较，再进行分割、匹配、查找、替换等工作。
	5、正则表达式和函数一起使用才起作用，否则就是个普通字符串
	6、PHP中提供了两套正则表达式函数库，一种是POSIX扩展正则表达式（以ereg_开头的函数），一种是与Perl兼容的正则表达式函数(以preg_开头的函数），推荐使用后一种
	7、正则两方面需要学习：1、正则表达式的模式如何编写  2、正则表达式的处理函数


正则表达式语法
	1、定界符号
		开始和结束符号 /
		除了字母、数字和反斜线\以外的任何字符都可以为定界符
		||
		//
		{}
		!!
		但无特殊需要，都使用正斜线//
	2、原子
		img \s
		原子是正则表达式的最基本组成单位，一个正则表达式中必须至少要包含一个原子
		正则表达式可以单独使用的字符就是原子

		1、包含所有打印和非打印字符
		2、有意义的字符如元字符，想作为原子使用，则可以用转义字符\
		3、经转义后，一些代表范围的原子：
			\d	任意一个十进制数字
			\D	任意一个非数字之外的字符
			\s	任意一个空白字符 \n\r\t\f
			\S	任意一个非空白字符
			\w	任意一个字a-zA-Z0-9_
			\W	任意一个非字
		4、使用[]自定义原子表，可以匹配[]中的任意一个原子
			[a-f4-9]
			[^a-f] ^表示取反，就是除了原子表中的原子，^必须是[]中的第一个字符
		5、.
			默认情况下，表示换行符外任意一个字符

	3、元字符
		是一种特殊字符，是用来修饰原子的，不可以单独出现
		?	前面的原子可以出现0次、1次
		+	前面的原子可以出现1次或多次
		*	前面的原子可以出现0次、1次或多次
		{}	自定义前面原子出现次数
			{m}	//m表示一个正数，表示前面原子出现m次
			{m,n}	//m小于n，表示前面原子最少出现m次，最多出现n次，包括m和n次
			{m,}	//表示前面的原子最少出现m次，最多无限
			{,n}	//表示前面的原子最多出现n次
		^	作为正则表达式的第一个字符出现，则表示必须以这个正则表达式开始	
		$	作为正则表达式的最后一个字符出现，则表示必须以这个正则表达式结尾
		|	表示 或 的关系，它的优先级是最低的，最后考虑它的功能
		\b	表示一个边界
		\B	表示一个非边界
		()	重点：
				1、作为大原子使用
					"/abc+/"
					"/(abc)+/"
				2、改变优先级，加括号可以提高优先级
					"/cat|dog/"
					"/ca(t|d)og/"
				3、作为子模式使用
					全部匹配作为一个大模式，放到数组的第一个元素中
					每个()是一个子模式，按顺序放到数组的其他元素中
				4、可以取消子模式，就将()作为大原子或改变优先级使用
					(?:)
				5、反向引用，可以在模式中直接将子模式取出，再作为正则表达式的一部分
					\n 取第n个子模式
					使用注意，正则被单引号和双引号括起来时还不相同
					双引号 "\\n"
					单引号 '\n'
					或使用下列方式
					${n}
		元字符的优先级顺序
			第一优先级：\
			第二优先级：() (?:) []
			第三优先级：* + ? {}
			第四优先级：^ $ \b
			第五优先级：|

	4、模式修正符号
		"\\模式修正符"
		只有模式修正符放定界符之外

		i	表示匹配时不区分大小写
		m	默认情况，无论字符串多少行都视为一行；加m后则每行的开头和结尾都分别匹配^和$
		s	默认情况，元字符中的"."不能表示换行符号，加s后将字符串视为单行，"."则可匹配换行符号
		x	表示模式中的空白忽略不计	
		e	正则表达式必须使用在preg_replace替换函数中时才可以使用
		U	默认为贪婪模式，加U则取消贪婪模式
			但有的语言不支持模式修正符号，另一种使用?完成 .*?  .+?
			但上述两种方式同时使用，则开启了贪婪模式

	/原子和元字符/模式修正符号 

		/为定界符，一些儿语言不需要定界符


正则表达式函数
	
	1、字符串匹配和查找

	preg_match();
		将正则表达式和字符串进行匹配，遇到第一个匹配则停止，并返回1，没有遇到匹配则返回0，发生错误返回false，一般用于验证email等
	
		参数1：正则表达式
		参数2：字符串
		参数3：匹配到的结果，为 一 维数组
		参数4：
		参数5：

		只是检测字符串中是否包含另一个字符串，可以使用下面的字符串函数：

		strstr()
			从搜到的字符串到结尾的剩余字符串
			参数1：源字符串
			参数2：要搜索字符串
		stristr()	//不区分大小写

		strpos()
			一个字符串在另一个字符串中最先出现的位置
		stripos()
			一个字符串在另一个字符串中的最后出现的位置

		substr()
			返回子字符串

			参数1：源字符串
			参数2：开始位置，大于0则从头部算起，字符串的位置从0开始
					 小于0则从尾部算起，字符串的位置从1开始
					 大于等于字符串长度，则返回false
			参数3：字符长度，不提供则取到字符串末尾
                                         为0、false或null则返回空字符串
					 小于0则表示末尾要保留几位字符串

	preg_match_all();
		将正则表达式和字符串进行匹配，会完整检测每一个匹配，并返回匹配次数，没有匹配到则返回0，发生错误返回false

		参数1：正则表达式
		参数2：字符串
		参数3：匹配到的结果，为 多 维数组
		参数4：指定匹配结果的顺序，为PREG_PATTERN_ORDER PREG_SET_ORDER，默认为前者
		参数5：

	preg_grep();

	preg_quote();

	2、字符串中的替换函数
		
	str_replace
		参数1：查找的字符串
		参数2：替换为的字符串
		参数3：源字符串
		参数4：替换的次数

		因参数为mixed类型，参数不仅可以为字符串，总结有如下用法：
		str_replace(string,string,string)	
		str_replace(array,string,string) //数组为字符串数组	
		str_replace(array,array,string)//替换时两个数组元素一一对应	
	str_ireplace	//不区分大小写

	preg_replace
		参数1：正则表达式
		参数2：替换为的字符串
		参数3：源字符串
		参数4：限制替换几次

		因参数为mixed类型，参数不仅可以为字符串，总结有如下用法：
		1、正常使用 
			preg_replace(string,string,string);
		2、将正则中匹配到的子模式使用到第二个参数中
			preg_replace(string,'\1\2',string);
		3、在第二个参数中调用函数，需要第一个参数正则表达式中使用e模式修正符			preg_replace('\这里是正则注意后面的e，保证了调用函数的成功\e','myfun(\2)',string);
		4、在前两个参数中都使用数组，可以一起将多个正则模式同时替换为对应字符串

	preg_replace_callback

	3、字符串的分割函数

		explode();

		preg_split();

		implode();


文件处理概述
	1、文件处理都是使用系统函数完成的
	2、这些函数都是基于linux/unix系统为模型

文件处理
	1、获取文件类型
		windows中只能获取file、dir、unknown三种类型
		linux中的所有类型均可获取：block、char、dir、fifo、file、link、unknown
			block：块设备文件，如磁盘分区，软驱，光驱
			char：字符设备，I/O中以字符为单位的设备，如键盘、打印机
			dir：目录也是文件的一种
			fifo：命令管道，信息从一个进程传入另一个进程
			file：普通文件
			link：链接文件

		filetype(目录或文件名);
		is_dir();
		is_file();
		is_link();
		is_writable(); 别名 is_writeable();
		is_readable();
		is_executable();
		is_uploaded_file(); //判断文件是否通过HTTP POST上传
	2、获取文件属性
		file_exists();
		filesize();
		filectime(); //inode修改时间，并不是创建时间，很多unix文件系统没有创建时间
		filemtime(); //文件内容修改时间
		fileatime(); //最后访问时间
		stat();	

	3、和文件路径相关的函数

		路径分隔符
			linux/unix  	/
			windows		\
				因\同时也是转义字符，因此在双引号中，使用\做分隔符时，需要其避免和后面的字符组成转义字符，需要使用两个\
				"c:\\windows\\ntext"

			分隔符常量：DIRECTORY_SEPARATOR 在不同系统上，会自动转换

			不管什么系统，PHP的目录分隔符都支持/

			PHP和Apache的配置文件中，也都使用/做为分隔符

		相对路径
			.	当前目录
			..	上一级目录

			./login.php 和 login.php 效果相同

		绝对路径
			/	根路径，存在两种情况
				客户端访问服务器端文件时，是通过apache访问，apache只能管理网站目录，所以根指的是网站根目录
					echo "<img src='/logo.gif'>";	
				在服务器中执行路径，根指的是操作系统根目录
					file_put_contents("/aaa.txt","abc");

		basename();
		dirname();
			可以通过嵌套取得上级的上级目录
			dirname(dirname("./aaa/bbb/ccc.php"));
		pathinfo();

	4、文件操作

		创建文件
			touch();
		删除文件
			unlink();
		移动文件/为文件重命名
			rename("当前文件路径","目标文件路径");
		复制文件
			copy("当前文件路径","目标文件路径");

		以上操作需要PHP执行对应文件的权限，即apache对应的用户有此权限

		和权限设置相关的函数：
			chgrp
				改变文件所属组
			chown
				改变文件所有者
			chmod
				改变文件模式

			filegroup
			fileowner

	5、读写文件内容

		file_get_contents(); //需php5支持
			读取文件中全部内容后并返回
		file_put_contents(); //需php5支持
			文件不存在，则自动创建后再写入内容
			文件存在，则覆盖文件内容
			不能追加内容，也不能加锁

		file();
			读取文件全部内容并返回数组，每行为一个元素
		readfile();
			读取文件中全部内容后并全部输出

		fopen();
			返回值：成功返回资源类型，失败返回false
			参数1：文件路径
			参数2： r	以只读的模式打开
				r+	除了读，还可以写
				w	以只写的方式打开，文件不存在，则创建文件并写入，文件存在则覆盖原内容
				w+	除了写，还可以读
				x
				x+
				a	以只写的方式打开，文件不存在，则创建文件并写入，文件存在则在原文件内容后追加
				a+
				b	以二进制模式打开文件，如图片、电影，但需要和r、w联合起来使用，如rb、wb
				t	以文本模式打开文件
		fclose();
			资源类型需要关闭，再次读取时也需要先关闭再打开

		fwrite(); //别名fputs();
			参数1：fopen返回的文件资源
			参数2：写的内容

		fread();
			参数1：fopen返回的文件资源
			参数2：读取指定长度字符


			读取本地文件中的全部内容，使用filesize
			$file=fopen("demo.php","r");
			echo fread($file,filesize($file));
			fclose($file);

			读取远程文件中的全部内容，使用feof
			$str="";
			$file=fopen("http://www.163.com/","r");
			while(!feof($file)){
				$str.=fread($file,1024);
			}
			fclose($file);
			echo $str;

			feof();
				参数：文件资源
				如果文件打开错误或到文件末尾则出错

		fgetc();
			一次从文件中读取一个字符
		fgets();
			一次从文件中读取一行字符

		以上函数支持本地和远程文件，如远程 echo file_get_contents("http://www.163.com/");

	6、文件内部指针移动
		ftell();
			返回当前文件指针位置
		fseek();
			移动文件指针
		rewind();
			移动指针到文件头部

	7、文件锁定的机制处理
		flock();
			为文件加锁，释放文件锁


目录处理

	不同于文件的各种操作都有系统函数，目录的各种操作都需要自己编写函数，创建目录除外。

	1、遍历目录
		opendir();
		readdir();
		closedir();
		rewinddir();
		is_dir();
	2、创建目录
		mkdir();
	3、删除目录
		rmdir();
			删除空目录
			自己编写删除非空目录
	4、重命名/移动目录
		prename();
	4、复制目录
		自己编写
	5、统计目录大小
		自己编写

文件上传

	PHP配置文件中和上传文件有关的选项

		file_uploads = on
			允许使用php上传文件

		upload_max_filesize = 200M	
			最大不要超过系统内存

		post_max_size = 250M
			此项值除了包含上传文件本身外，还包括表单的其他数据，如商品名称等，所以要大于上面的值

		upload_tmp_dir = c:/upload

	上传表单需要注意的事项
	
		指定表单编码的数据方式enctype="multipart/form-data"（只有上传文件才使用这个值），并带有一些常规的信息

		提交方法必须是HTTP POST

		使用<input type="file">来选取上传文件

		建议加上<input type="hidden" name="MAX_FILE_SIZE" value="1024000">，单位是字节

	PHP处理上传的数据

		$_POST
			处理非上传数据

		$_FILES
			处理上传文件的数据

			Array
			(
			 [name] => hello.jpg
			 [type] => images/pjpeg
			 [tmp_name] => c:\windows\temp\php68.tmp //脚本结束时此临时文件即被删除，将此临时目录的文件用脚本移动到指定目录即完成上传
			 [error] => 0
			 [size] => 24485
			)

			上传文件还需注意：
			1、使用$_FILES["mypic"]["error"]检查错误
			2、使用$_FILES["mypic"]["size"]限制大小，单位字节 2M=pow(2,20);
			3、使用$_FILES["mypic"]["type"]或文件的扩展名限制类型
				Apache的mime.types可以查看所有MIME类型

				list($bigtype,$smalltype)=explode("/",$_FILES["mypic"]["type"]);
				if($bigtype!="image"){

				}else{

				}
			4、将上传后的文件名改名，防止用户意外访问

				先使用is_uploaded_file()判断是否为上传文件

				再使用move_uploaded_file()移动上传文件，不使用copy() rename()等函数

文件下载

	http请求:
		1、协议和版本 HTTP 1.1
		2、头信息
		3、表单信息

	http响应：
		1、状态 200 ok 404 页面没找到
		2、响应头信息
		3、数据发送

	按HTTP协议的报文顺序，下述的header前不能有任何输出：
	<?php
		header("Content-Type:text/html;charset=utf-8");
		header("Location:two.html");
	?>

	告诉浏览器以附件形式处理：
		
		header('Content-Disposition:attachment;filename="mytwo.html"');
		readfile("two.html");

		header("Content-Type:image/gif");	//即使不加此行，浏览器也可能自动检测
		header('Content-Disposition:attachment;filename="logo.gif"');
		header("Content-Length".filesize("logo.gif"));	//即使不加此行，浏览器也可能自动检测
		readfile("logo.gif");
		readfile("two.html");

文件上传类：
		function __construct($options=array()){
			foreach($options as $key=>$val){
				if(in_array($key,get_class_vars(get_class($this)))){
					this=>$key=$val;
				}
			}
		}


错误类型
	1、语法错误
	2、运行时错误
	3、逻辑错误

错误报告
	php配置文件中和错误相关的搜"Error handling and logging"
	或
	使用下列PHP函数设置错误报告：

		error_reporting(E_ALL & ~E_NOTICE & E_WARNING);

		ini_set("error_reporting",E_ALL);


		echo ini_get("error_reporting");

	错误 E_ERROR
	警告 E_WARNING
	注意 E_NOTICE


	getType($var); //注意，程序仍继续执行
	getType(); //警告，程序仍继续执行
	getType() //错误，程序终止执行

	上面的语句加@可临时屏蔽掉所有的注意、警告和错误，即：

	@getType($var); 
	@getType(); 
	@getType() 

错误日志

	1、指定错误日志
		ini_set("error_reporting",E_ALL);
	2、关闭错误输出
		ini_set("display_errors","off"); 
		设置此值发生错误将不输出到浏览器
		如果不指定错误日志位置，将默认写入web服务器的错误日志中，如apache错误日志
		若此值设置为true，则输出到浏览器，但不会再写入apache错误日志
	3、开启错误日志功能
		ini_set("log_errors,"on");
	4、指定错误日志文件
		ini_set("error_log","c:/error.log");

		设置为syslog则将错误写入了操作系统的错误日志中：
		ini_set("error_log","syslog");
	5、使用函数产生错误日志	
		error_log("this is a error message");


	建议开发时输出所有的错误报告，有利于进行程序调试；运行阶段不要输出任何错误报告。

异常处理
	意外，程序运行过程中发生的意料之外的事
	是php5的一个新特性

	try{

		throw new Exception("xxx失败");

		throw new MyException1("xxx失败");

		throw new MyException2("xxx失败");

	}catch(MyException1 $异常参数){

	}
	}catch(MyException2 $异常参数){

	}
	}catch(Exception $异常参数){	//将系统的Exception处理放最后，这样如果Exception的子类没有对应的catch，则会交给Exception类

	}

	1、如果try中代码没有问题，则不执行catch代码
	2、如果try中有异常发生，则在try中抛出异常对象，且抛给了catch中的异常参数，抛出异常后try中的代码中断执行，跳转到catch中去执行
	3、我们主要做的不是提示发生了什么异常，而是要在catch中解决这个异常，解决不了，则输出给用户。

内置异常类和自定义异常类

	1、自定义异常类必须是内置异常类的子类
	2、内置异常类只要构造方法和toString可以重载，其他都是final
	3、自定义异常类应该是解决当发生此异常时的处理，即在这里换种方法实现发生异常代码要完成的功能，而不是通知


日期和时间

	1、UNIX时间戳
		以32位整数表示格林威治标准时间
		这个整数是从1970年1月1日0时0分0秒到现在的秒数，1970年1月1日0时0分0秒被称为计算机元年
		最主要功能是方便计算使用
		因整数的范围，时间戳处理的时间范围为1907---2038年

	2、在PHP中获取日期和时间
		time();
			获取UNIX时间戳
		getDate();
			返回数组
		getTimeOfDay();
		date_sunrise();
		date_sunset();

	3、日期和时间的格式化输出
		date(string,[timestamp]);

		date("Y-m-d H:i:s",time());
		date("Y-m-d H:i:s");

	4、将日期和时间转换为UNIX时间戳
		mktime(时,分,秒,月,日,年);

	5、修改php默认市区
		修改php配置文件date.timezone=

		date_default_timezone_set("PRC");
		date_default_timezone_set("Asia/Shanghai");
		date_default_timezone_set("Gtc/GET-8");

	6、使用微秒计算PHP脚本执行时间

		microtime(true);


PHP图像处理

	首先安装GD库 ---lamp环境安装
	php配置文件中设置php_gd2.dll
	利用phpinfo查看是否支持gd库

	一、画图
		验证码、统计图

		1、创建画布，为一资源类型，需要指定高度和宽度

			imagecreate();
			imagecreatetruecolor();	//推荐使用

			$img=imagecreatetruecolor(200,200);
		2、填充颜色
			imagecolorallocate();//和imagecreate()搭配使用
			imagefill(); 
			
			$red=imagecolorallocate(255,0,0);
			$green=imagecolorallocate(0,255,0);
			imagefill($img,0,0,);

		3、绘制图像，可绘制：
			矩形，圆、点、线段、扇形、字符、字符串、freetype字体
			上述每一个图像对应一个函数
			imagefilledrectangle
			imagerectangle
			imageline
			imagesetpixel
			imageellipse
			imagefilledellipse
			imagefilledarc

			imagefilledrectangle($img,10,10,80,80,$green);

			imagechar
			imagecharup
			imagestring
			imagestringup
			imagettftext
			iconv
				汉字gb2312的需要转换为utf-8
				使用非php的内置字体最好将字体文件复制到程序目录下
		4、输出图像或保存成文件
			输出各种类型:gif、jpg、png
			imagegif();
			imagejpeg();
			imagepng();

			header("Content-type:image/gif");
			imagegif($img);
		5、释放资源
			imagedestroy($img);

	二、处理原有图像
		缩放、加水印、电子相册

		imagetypes()

		if(imagetypes() & IMG_GIF){
			header("Content-type:image/gif");
			imagegif($this=>image);
		}

图片处理

	裁剪、缩放、翻转、锐化、透明、旋转	

	1、创建图片资源
		imagecreatefromgif(图片名称);
		imagecreatefrompng(图片名称);
		imagecreatefromjpeg(图片名称);

		imagesx();
		imagesy();
		getimagesize();
	2、图形处理
		裁剪、缩放：imagecopyresized
		等比例裁剪、缩放：imagecopyresampled
			 固定方案：66节 43:05
		透明处理：png、jpeg透明色都正常，只要gif不正常
			 imagecolortransparent();
			 imagecolorstotal();
		 	 imagecolorsforindex();
			 固定方案：66节 43:05
		加水印：文字水印、图片水印
			 imagecopy();
		旋转：imagerotate();
		翻转：水平翻转、垂直翻转
			无系统函数，使用的是逐行复制图片的方式
		锐化、浮雕：imagecolorsforindex();
			imagecolorat();
			imagecolorexact();
			无系统函数，逐个获取图像像素，颜色加重后放入新图像

		开发中常用为缩放和加水印。
	3、保存图片
		imagegif();
		imagepng();
		imagejpeg();

MySql架构

	c/s结构，端口3306 

	根目录下配置文件my.ini
	/bin目录：存放mysql的所有命令，windows下较少
	/data目录：mysql的数据库目录，一个子目录对应一个库，子目录下对应的文件为表

sql语句
	structured query language

	DDL,DML,DQL,DCL

	mysql -h localhost -u root -p  //-p后面输入密码时不要有空格，但建议这时不输入密码，因为这时密码时明文显示，直接回车，会提示输入密码，这时会显示为*号

	/s 查看mysql状态
	show variables;  查看系统配置变量
	show variables like 'ssh';
	show database;
	create database if not exists 库名;
		在/mysql/data目录下直接建立文件夹haha，则相当于建立了一个数据库
	drop database if exists 库名;
		在/mysql/data目录下删除文件夹haha，则相当于删除了一个数据库
	use 库名;	//选择一个库作为默认库
	show tables;
	desc 表名;	查看表结构
	create table if not exists users(id int, name char(30), age int,sex char(3));
		表的3个文件：结构、数据、索引
	drop table if exists 表名;
	insert into users values(1,'zhangsan',10,'boy');
		所有的字段按字符串处理，mysql会自动转换
	insert into users values('1','zhangsan','10','boy');
	insert into users(id,name,age) values('2','lisi','11');
	select * from users;
	update users set name='wangwu',age='21' where id='2';
	delete from users where id='2';

	? contents 查看帮助包括哪些儿内容
	? data types 上面命令中列出的均可在前面加?号进行查看
	? int

	? show
	? create table

	\c 退出多行命令

创建数据库表

	create table [if not exists] 表名(
		字段名1 列类型 [属性] [索引]
		字段名2 列类型 [属性] [索引]
		......
		字段名n 列类型 [属性] [索引]
	) [表类型] [表字符集];

	SQL语句不区分大小写，但是一个表对应x个文件名，windows不区分大小写，linux区分大小写，自己定义的名称最好都小写，SQL语句都大写。	

	列类型：

		细分都是按空间大小来区分的

		数据库的数据量大，空间分配不合理会造出很大的浪费，所以分配空间原则是能存下就可以，也因为如此数据库有很细的类型划分。

		1、数值型
			整型：
									有符号范围		无符号范围
				=================================================================================
				非常小的整型	TINYINT		1字节	-128---127		0----255
				较小的整型	SMALLINT	2字节	-32768---32767		0----65535
				中等大小的整型	MEDIUMINT	3字节				0----16777215
				标准的整型	INT		4字节	-2147483648---2147483647
				大整数型	BIGINT		8字节
			浮点型：
				float(M,D)		4字节		//M代表总位数,D代表小数位数
				double(M,D)		8字节
				decimal(M,D)		M+2字节		//定点数，以字符串形式存放

				浮点数会四舍五入
				浮点数存在误差，是近似数，不能使用==比较
				对比较敏感数据，使用定点数处理
				定点数优点是精确，但效率低于浮点数
		2、字符串型
			char(m)		默认255个字符，固定长度字符串，长度是定义的字节数，select后回删除空格，查询速度快，浪费空间，适合数据变化不大
			varchar(m)	默认255个字符，可变长度字符串，长度是内容长度+1个字节，select后保留空格，查询速度慢，节省空间
			text	变长，最大长度2^16-1，保存大数据量文本数据
				MEDIUMTEXT
				LONGTEXT
			blob	变长，最大长度2^16-1，保存二进制数据，如照片，压缩包，电影
				MEDIUMBLOB
				LONGBLOB
			ENUM	枚举，1或2字节，一次只能用一个值
			SET	集合，1,2,3,4,8字节，一次可以用多个集合的值，中间使用“,”分开即可

		3、日期型
			DATE		YYYY-MM-DD
			TIME		hh:mm:ss
			DATETIME	YYYY-MM-DD hh:mm:ss
			TIMESTAMP
			YEAR		YYYY

			创建表时最好不要使用这些时间格式，而用整型time()保存时间，比这些时间格式方便参与运算。（？？？？）


	数据字段属性
		1、unsigned	无符号，插入负值时会自动转为0
				只能用在数值型字段，即整型和浮点型
		2、zerofill	前导0，不足的位数自动用0补齐
				只能用在数值型字段，即整型和浮点型
				该字段自动应用UNSIGNED
		3、AUTO_INCREMENT	只能是整数
					数据每增加一条，字段值自动加1，删除数据后，仍从原最大值加1开始，而不是从最大值开始
					字段值不允许重复，因此定义时还需要将此列定义为key
					当插入数据为NULL 0 留空时，即自动插入值
					插入时指定了值，再插入值则从最大那个值开始加1
		4、NULL和NOT NULL
				建议：在创建表时，字段都不允许插入NULL值，因mysql的NULL转为php的值时，不一定等于''或0等

		5、default
				设置默认值


	索引
		1、主键索引
			primary key
			主要作用是确定数据库表中一条特定数据记录的位置，用来唯一标识一条记录
			最好为每张数据表定义一个主键。
			一个表只能指定一个主键
			主键的值不能为空

		2、唯一索引
			unique
			和主键索引一样，都可以防止创建重复的值
			不是为了提高数据操作速度
			每个表都可以有多个唯一索引

		3、常规索引
			最重要的技术，可以提升数据库的性能
			性能优化最先考虑的即常规索引
			可以提高查找的速度，会减慢数据列上插入、删除、修改的速度
			和表一样是独立的数据对象，可在创建表时创建，也可以单独使用

			create table table_carts(
				id int not null,
				id int not null,
				id int not null,
				id int not null,
				primary key(id),
				index cuid(uid),	//index 和 key是同义词，因此这行和下面的一行都是创建索引
				key csid(sid),
			);
			create index ind1 on users(name,age);

			drop index ind1 on users;

		4、全文索引
			fulltext类型索引，只能用在MyISAM表类型上使用
			只有在varchar、char、text文本字符串上使用
			也可以多个数据列使用
			create table books(
				id int,
				bookname varchar(30),
				price double,
				detail text not null,
				fulltext(detail,bookname),
				index ind(price),
				primary key(id)
			);

			通常sql：select * from books where bookname like '%php%';

			全文检索：select bookname,price from books where MATCH(detail) AGAINST('php');
				  select match(detail) against('php') from books;


	表类型和存储位置

		mysql和大多数据库不同，mysql有一个存储引擎的概念

		mysql可以针对不同的需求选择最优的存储引擎

		通常也把支持的存储引擎叫数据表类型

		使用show engines查看mysql支持的数据引擎，12种，缺省为MyISAM

		也可使用show variables like 'table_type';查看表类型，即引擎类型

		重要的表类型有：MyISAM 和 InnoDB

		create table() type InnoDB;
		或
		create table() engine InnoDB;

		在一个mysql库中可以有不同的表类型

		MyISAM表类型特点：
			成熟、稳定、易于管理
			OPTIMIZE TABLE 表名;  优化碎片
			强调快速读取操作

			缺点是有些儿功能不支持

		InnoDB表类型特点：

			支持一些儿MyISAM所不支持的功能

			缺点是空间占用较多，读写速度比MyISAM慢

		功能			MyISAM				InnoDB
		==================================================================
		事物处理		不支持				支持
		数据化锁定		不支持				支持
		外键约束		不支持				支持
		表空间占用		相对小				相对大，最大2倍
		全文索引		支持				不支持


		存储位置：
			MyISAM文件：
			  	.frm	存储表结构
			  	.MYD	存储数据
			  	.MYI	存储索引
			InnoDB文件
				只有.frm文件，既存表结构，又存数据和索引（？？？）

	MySQL默认字符集

		GBK	定长的字符集，是否汉字都占2字节
		UTF-8	变长的字符集，1到4个字节，每个汉字3个字节

		MySQL服务器、数据库、表、字段都可以指定字符集，36个

		显示字符集show character set;

		注意数据库中的utf-8没有-

		MySQL的字符集包括

			字符集：用来定义MySQL存储字符串的方式

			校对规则：是对规则定义了比较字符串的方式
				以_ci结尾的校对规则表示区分大小写
				以_cis结尾的校对规则表示不区分大小写
				以_bin结尾的校对规则表示进行二进制比较

			一对多的关系，一个字符集可以对应多个校对规则

			查看对应关系：show collation like '%gbk%';

		create database demo default character set gbk collate gbk_chinese_ci;
		create table t1(id int) type=InnoDB default character set gbk collate gbk_chinese_ci;
		alter database demo character set utf8;

		 客户端与服务器交互时：
			character_set_client
			character_set_connection
			character_set_results

		mysqldump -u root -p --default-character-set=gbk -d demo1 > c:\demo.sql
		mysql -u root -p demo1 < c:\demo.sql

			set names 字符集 同时修改以上三个的值
修改表

	alter table t1 add name varchar(30) not null;
	alter table t1 add age int unsigned not null default '0';
	alter table t1 add sex varchar(10) not null after name;
	alter table t1 add height double first;

	alter table t1 modify sex char(3); //modify更改类型，change改名字
	alter table t1 change name1 name2 varchar(30);
	alter table t1 rename as users;

	alter table t1 drop age;
	drop table if exists t1;


insert into 表名([字段列表]) values(值列表1),values(值列表2),values(值列表3);

truncate 表名;	

select [all | distinct]

	distinct不是针对一列数据的，是针对整个查询列表取消重复的一列，在多个字段时表示字段的组合不相同

	select distinct a,b from t1

	select version(),1.2*10;
		上述sql中的括号，*等在嵌入到php中时，可能会产生问题，要使用别名

	逻辑运算符
		&& and
		|| or
		!  not

	比较运算符
		=	--sql中的等于是一个等号
		<=>	和=作用相同，但可以用于null值判断，而=不可以，需要使用is null 判断
		!= <>
		<
		<=
		>
		>=
		is null
		is not null
		between and	包括两个边界
		not between and
		like	两个通配符：下划线_ 表示任意一个字符；%表示0个或多个字符
		not like
		in
		regexp rlike
from

where

group by 

having
	分组后的条件判断
	select cid,count(*) from t group by cid having cid > 200;

order by 

limit
	单独从句，用于限制条数
	
	select * from t order by a desc limit 0,5;

窄表 宽表 疑惑
笛卡尔连接

Mysql中的内置系统函数

	字符串函数

		concat(s1,s2.....sn) 把传入的参数连接为字符串
			concat "abc","xyz"
			select concat(name," age is",age);

		insert(str,x,y,str1) 将字符串str的x（下标从1开始）位置开始，y个长度的字符串替换为str1

		replace(str,a,b) 将字符串str的a替换为b

		lower()  upper()

		left(str,x)  right(str,x)

		lpad(str,n,pad)  rpad(str,n,pad) 用字符串pad对str最左边或最右边进行填充，直到字符串长度为n

		trim() ltrim() rtrim()

		strcmp(s1,s2) 按ascii码比较字符串，s1>s2 返回1 s1=s2 返回0 s1<s2 返回-1

		substring(str,x,y) 返回字符串中的第x位置起y个长度的字符串

	数值函数
		abs(x)
		ceil(x) 返回大于x的最小整数
		floor(x) 返回小于x的最大整数
		mod(x,y) 返回x除以y的余数
		rand() 返回0-1之间的小数
		round(x,y) 返回参数x的四舍五入值，小数长度为y位
		truncate(x,y) 返回数字x截断为y位小数的结果，相对于上面的round，不会四舍五入

	日期函数
		curdate 返回当前日期
		curtime() 返回当前时间
		now()	返回当期日期和时间
		unix_timestamp(now())	返回当前的unix时间戳
		from_unixtime(129344485) 返回时间戳对应的日期
		week(now())
		year(now())
		hour(now())
		minute(now())
		monthname(now()) 月份名字，为英文，如December
		date_format(now(),"%Y-%m-%d %H:%i:%s");

	流程控制函数
		if(value,t,f)   --value为真，返回t，否则返回f
		ifnull(value1,value2)	--不是null返回value1，是null返回value2
		case 
			when [value1] then [result1] 
			when [value2] then [result2] 
			when [value3] then [result3] 
			... 
			else [value] 
		end

	其他函数
		database	返回当前数据库名
		version		返回当前mysql版本
		user		返回当前的登录用户
		inet_aton(ip)	返回IP地址对应的网络字节
		inet_ntoa	返回网络字节对应的IP地址
		password	返回41位长的加密字符串，用于mysql系统用户的密码加密
		md5


在PHP中使用MySQL扩展库操作数据库

	mysql_connect
	mysql_pconnect
	mysql_select_db
		一个页面有多个链接时，需要指定第二个参数，否则默认第二个参数为后建立的链接
	mysql_query
	mysql_insert_id	获取最后增长的ID
	mysql_affected_rows
	mysql_errno
	mysq_error
	mysql_close


使用PHP中mysql扩展处理结果集

	从结果集获取记录
		mysql_fetch_row		//返回索引数组，可以和list配合
			while(list($id,$name,$price)=mysql_fetch_row($result)){
				echo $id.$name.$price
			}
		mysql_fetch_assoc	//返回关联数组，下标为列名
		mysql_fetch_array	//返回索引和关联两个数组
		mysql_fetch_object	//将一条记录以对象的形式返回

		使用一次就从结果集中取出一条记录，取完后将指针移动到下一条记录，默认为第一条记录，到结尾则返回false

		mysql_data_seek
			移动结果集的指针

	获取行列的信息
		mysql_num_fields
		mysql_filed_name
		mysql_num_rows

	释放结果集
		mysql_free_result

	翻页类：
	$_SERVER["REQUEST_URI"]
	parse_url
	parse_str
	http_build_query


PHP的mysqli扩展库操作MySQL数据库

	从php5.0开始可以使用mysqli，i表示改进
	mysqli是一个面向对象的技术，但也支持过程化的使用方式，建议使用面向对象开发
	相对mysql改进：
		1、功能增加
		2、效率提高，新项目建议使用mysqli
		3、更稳定

	使用mysqli需要：
		为php安装mysqli扩展
		在php的配置文件中打开mysqli的扩展

	mysqli提供了三个类：
		1、mysqli
			和连接有关的类
		2、mysqli_result
			和结果集有关的类

			上述mysqli的两个类即完成了mysql的功能
		3、mysqli_stmt
			预处理类


	$mysqli=@new mysqli("localhost","root","123","mydb"); //注意new前的@屏蔽了错误输出
	if(mysqli_connect_errno()){
		echo mysqli_connect_error();
		$mysqli=null;
		exit;
	}
	echo $mysqli->character_set_name()."<br>";
	echo $mysqli->get_client_info()."<br>";
	echo $mysqli->host_info."<br>";
	echo $mysqli->server_info."<br>";
	echo $mysqli->server_version."<br>";

	$result=$mysqli->query($sql);

	if(!$result){
		echo $mysqli->errno.$mysqli->error;
	}

	echo $mysqli->affected_rows;
	echo $mysqli->insert_id;


使用PHP中mysqli扩展处理结果集

	$result->num_rows;
	$result->field_count;

	$result->fetch_row;
	$result->fetch_assoc;
	$result->fetch_array;
	$result->fetch_object;

	$result->data_seek(5);

	$result->fetch_field();
	$result->fetch_fields();
	$result->field_seek();

	$result->free();
	$result->free_result();
	$mysqli->close();


使用PHP的mysqli扩展完成事务处理和一次执行多条SQL语句




使用PHP的mysqli扩展中预处理语句

   1、多条语句

	$mysqli->multi_query("sql1;sql2;sql3;");
	do{

		$result->$mysqli->store_result();

		if($mysqli->more_results()){
			echo "还有结果集";
		}
	}while($mysqli->next_result());

   2、事务

	目前只有InnoDB 和 BDB 表类型支持事务

	默认表都是自动提交的(autocommit)，因此使用事务需要先关闭自动提交，改为手动提交

	命令行中的操作：
		1、关闭自动提交
			set autocommit=0;
		2、开启事务
			start transaction;
		3、提交
			commit;
		4、回滚
			rollback;
	程序中的操作：
		1、关闭自动提交
			$mysqli->autocommit(0);
		2、开启事务
			start transaction;
		3、提交
			$mysqli->commit();
		4、回滚
			$mysqli->rollback();
		5、开启自动提交
			$mysqli->autocommit(1);

   3、mysqli中其他类成员的使用
	
	更改字符集
		$mysqli->query("set names gb2312");
		$mysqli->query("insert into t1(id,name) values(1,{$_GET("prname")})");

		$mysqli->set_charset("utf8");


使用PHP的mysqli扩展中预处理语句

	预处理类mysqli_stmt，和mysqli，mysqli_result相比优点：
		1、mysqli和mysqli_result完成的功能，都能使用mysqli_stmt完成
		2、效率高，编译一次，执行多次
		3、安全，使用问号占位符防止sql注入
	因此推荐使用

	第一种方法：
		$stmt=$mysqli->stmt_init();

		$sql="insert into t1(id,name,price,desn) values(?,?,?,?)";
			sql中的?即为问号占位符

		$stmt->prepare($sql);

	第二种方法：
		$stmt=$mysqli->prepare($sql);


	给占位符的每个?传值，也称为绑定参数
		$stmt->bind_param("idsb",$a,$b,$c,$d);
			i   corresponding variable has type integer
			d   corresponding variable has type double
			s   corresponding variable has type string
			b   corresponding variable is a blob and will be sent in packets

			$a,$b,$c,$d必须传变量，不能直接传值，因为这里的参数需要是引用


	执行，可以先绑定参数，后为参数赋值
		$a="1";
		$b="2";
		$c="3";
		$d="4";
		$stmt->execute();

		$a="1";
		$b="2";
		$c="3";
		$d="4";
		$stmt->execute();

		$a="1";
		$b="2";
		$c="3";
		$d="4";
		$stmt->execute();
	释放
		$stmt->close();


	处理结果集
		$stmt=$mysqli->prepare("select id,name,price from t1 where id > ?");

		$stmt->bind_param("i",$id);

		$stmt->bind_result($id,$name,$price);	//将每一列绑定到对应的变量

		$id=99;

		$stmt->execute();

		$stmt->store_result();	
			//一次性将结果取过来，没有这条语句则是逐条取，效率低，且下面的data_seek方法和num_rows都无法正确执行

		$result=$stmt->result_metadata();
			//此方法虽返回的是mysqli_resul结果集对象，但只能使用获取字段的方法

		while($field=$result->fetch_field){
			echo $field->name;
		}

		$stmt->data_seek(2);

		while($stmt->fetch()){		//循环取每一行

			echo $id.$name.$price;

		}

		echo $stmt->num_rows;

		$stmt->free_result();

		$stmt->close();


PHP中使用MySQL的视图

	什么是视图
		视图是存放数据的一个接口，是虚拟表
		数据来自一个或几个基表或视图，也可以是用户自己定义的数据
		视图并不存放数据，数据还是存放在基表中
		基表数据发送变化，视图数据也随之变化；视图数据变化，基表数据也变化

	视图的作用
		1.视图可以让查询变得很清楚，让复杂的sql语句变得简单
		2.保护数据库的重要数据，给不同的人看不同的数据，可从基表中选择特定的字段生成视图，然后为用户分配此视图的权限，但基表不分配权限，则限制了用户查看数据的权限。

	视图分类
		定制视图
		传参视图 

		merge
			会将引用视图的语句
		temptable
		undefined

		[with [cascaded|local] check option]

	创建视图
		create [or replace] [algorithm={merge|temptable|undefined}]
		view view_name [(column_list)]
		as select_statement
		[with [cascaded|local] check option]

		create view student_view as select * from student; 

		创建或替换视图（弱同名视图已存在）
		create or replace view student_view as select id,name,age from student;

		指定视图字段名，注意字段名中有空格时使用的是反引号
		create view student_view(`编 号`,名字,年龄) as select id,name,age from student;
			视图名不能和基表名相同
			只有一个frm的结构存储文件

	更改视图

		 alter view student_view as select * from student; 

	删除视图
	
		drop view student_view;
		
	查看视图

		show tables;
		desc student_view;
		show table status like 'student_view' \G;
		show create view student_view \G;
		select * from information_scheme \G;

	web开发中使用视图

		登录时的用户名、密码字段放一个视图中

PDO的介绍安装及对象初使化

	PDO:PHP Data Object

	php处理不同的数据库需要调用不同的数据库扩展，如mysql,mysqli,orace,mssql等，这些扩展的调用方法虽然类似但不尽相同，在需要将数据从一个类型数据库移植到另一个类型数据库时，首先要使用工具将数据移动过去，然后最重要的是要修改程序中的数据调用方法，这是最烦琐最大量的工作，也因此，跨数据库的pdo应运而生，类似的技术还有adodb和mdb2，但pdo相对来说更高效。

	pdo是基于驱动的(adodb不是)，并不是pdo扩展本身去访问不同的数据库，而是安装对应数据库的pdo驱动，如pdo_mysql对应mysql的驱动

	启用pdo：
		安装pdo扩展
		安装对应数据库的驱动
		php配置文件中打开对应的驱动

	pdo的三个类
		PDO
			和数据库连接有关的类
		PDOStatement
			处理准备语句和结果集
		PDOException
			处理异常

	PDO很多常量

	创建PDO对象
		$pdo=new PDO($dsn,$username,$pwd);
			dsn data source name 

			数据源，包括主机位置、库名、连接哪种数据库驱动三种信息
			各数据库dsn的写法不同，可参考帮助
			可将dsn写入文件中或写入配置文件中，用户切换数据库时方便：
				pdo.dsn.mysqlpdo=mysql:host=localhost;dbname=demo

		try{

			$pdo=new PDO("mysql:host=localhost;dbname=demo","root","123456");

		}catch(PDOException $e){

			echo $e->getMessage();
			exit;
		}

		echo $pdo->getAttribute(PDO::ATTR_CLIENT_VERSION)."<br>";

		$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT,0);

		也可用第四个参数设置PDO的常量：

			$pdo=new PDO($dsn,$username,$pwd,array(PDO::ATTR_AUTOCOMMIT->0));


PDO对象中方法的使用详细介绍

	exec()
		执行有影响行数的sql
		返回影响的行数

		获取最后自增长ID：$pdo->lastInsertId();
	query()
		执行有结果集的sql
		返回的是预声明对象???，支持foreach遍历
	prepare()


	三种错误模式：？？？
		PDO::ERRMODE_SILENT
			默认模式下sql有错误不提示，需要使用错误函数获取错误信息
			errorcode
			errorinfo
		PDO::ERRMODE_WARNING
			警告模式下trycatch不会捕获到异常
		PDO::EXCEPTION
			异常模式下可以抓取到异常

	事务：
		$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT,0);
		$pdo->beginTransaction();
		$pdo->commit();
		$pdo->rollback();
		$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT,1);

使用PDO进行SQL语句预处理

	//准备好了一条sql语句，并放到服务器端编译过了
	$stmt=$pdo->prepare("insert into t1(id,name,age,sex) values(?,?,?,?)");	
	$stmt=$pdo->prepare("insert into t1(id,name,age,sex) values(:id,:name,:age,:sex)");	
		返回的就是预处理类PDOStatement对象
		和mysqli的占位符只支持?占位符不同，这里也支持名字占位符
		?占位符是按索引顺序使用，名字占位符则是按名称使用，和顺序无关

	//绑定名字参数
	$pdo->bindParam(":id",$id,PDO::PARAM_INT);	//后面的类型是可选的，系统会自动转换
	$pdo->bindParam(":name",$name);
	$pdo->bindParam(":age",$age);
	$pdo->bindParam(":sex",$sex);

	//绑定问号参数
	$pdo->bindParam(1,$id);
	$pdo->bindParam(2,$name);
	$pdo->bindParam(3,$age);
	$pdo->bindParam(4,$sex);

	//为参数连续赋值和执行
	$id=1;
	$name="lisi";
	$age=10;
	$sex="boy";

	if($stmt->execute()){
		//获取最后插入ID
		echo $pdo->lastInsertId();
	}

	$id=2;
	$name="wangwu";
	$age=12;
	$sex="girl";

	if($stmt->execute()){
		//获取最后插入ID
		echo $pdo->lastInsertId();
	}

	//使用另一种方式执行，通过传递数组
	$stmt=$pdo->prepare("insert into t1(id,name,age,sex) values(:id,:name,:age,:sex)");	
	$stmt->execute(array(":id"=>1,":name"=>"lisi",":age"=>10,":sex"=>"boy"));//和数组元素顺序无关
	$stmt->execute(array(":id"=>2,":name"=>"wangwu",":age"=>12,":sex"=>"girl"));

	$stmt=$pdo->prepare("insert into t1(id,name,age,sex) values(?,?,?,?)");	
	$stmt->execute(array(1,"lisi",10,"boy"));//按占位符顺序传值
	$stmt->execute(array(2,"wuli",12,"girl"));

使用PDO操作结果集

	$stmt=$pdo->prepare("select * from t1 where id > :id");
	$stmt->execute(array(":id"=>12));

	$stmt->setFetchMode(PDO::FETCH_NUM);

	//逐条获取
	while($row=$stmt->fetch(PDO::FETCH_NUM)){
		foreach($row as $item){
			echo $item;
		}
	}

	//一次性全部获取
	$data=$stmt->fetchAll(PDO::FETCH_NUM);
	echo print_r($data);

	//通过绑定列的方式获取
	$stmt->bindColumn("id",$id,PDO::PARAM_INT);	//按名字绑定
	$stmt->bindColumn("name",$name);
	$stmt->bindColumn(3,$age);	//按顺序绑定
	$stmt->bindColumn(4,$sex);

	while($stmt->fetch()){
		echo $id.$name.$age.$sex;
	}

	//获取总行数
	echo $stmt->rowCount();

	//获取总列数
	echo $stmt->columnCount();

	//获取列信息
	for($i=0;$i<$stmt->columnCount;$i++){
		$field=$stmt->getColumnMeta($i);
		echo $field["name"];
	}

	fetch()
		默认返回的数据包含了索引和关联数组
		通过制定常量参数可以设置返回的数组
			PDO::FETCH_NUM
			PDO::FETCH_ASSOC
			PDO::FETCH_BOTH
		也可以通过设置获取模式来设置
			$stmt->setFetchMode(PDO::FETCH_NUM);

	fetchColumn
		获取单列

memcached的安装及管理

	概述
		是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个巨大的hash表
		hash表是一个键值对表
		是一个c/s架构软件？？？？
		150k的开源软件，使用c语言实现
		默认端口是11211

	工作原理
		Memcache	软件
		Memcached	服务进程

		Memcached是以守护进程方式运行于一个或多个服务器中，随时接收客户端的连接和操作
		客户端可使用各种语言编写，如PHP、java等
		
	linux下安装
		memcache使用到libevent库，需要先安装此库
			./configure-with-libevent=/usr
		安装memcache
			./config-with-libevent=/usr
			make && make install
			启动
				memcached -d -m 128 -l 192.168.1.11 -p 11211 -u root
			停止
				kill cat /tmp/memcached.pid
				或
				killall memcached

	windows下安装

		memcached.exe -d install

		memcached.exe -d uninstall

		memcached.exe -d start
		
		memcached.exe -d -m 50 -l 127.0.0.1 -p 11211 start
	操作
		telnet localhost 80	---apache
		telnet localhost 21	---ftpd
		telnet localhost 22	---ssh
		telnet localhost 11211	---memcached

	命令格式
		[add | set]	键  标志位  有效时间 长度 \n值
		[get | delete]  键
		flush_all	//清空所有

	遍历
		stats items
		stats cachedump 1 1
		stats cachedump 1 0

php中使用memcached

	支持过程和对象两种使用方式

	安装memcached扩展
		windows系统
			将php扩展文件php_memcache.dll复制到php扩展目录ext
			在php配置文件中设置memcache扩展：extension=php_memcache.dll
			重启apache服务器
		linux系统
			？？？？

	使用
		$mem=new Memcache;
		$mem->connect("localhost",11211);
		$mem->add("mystr","this is a test",MEMCACHE_COMPRESSED,3600);
		$mem->set("mystr","this is a test",MEMCACHE_COMPRESSED,3600);
		$mem->replace("mystr","this is a test",MEMCACHE_COMPRESSED,3600);
		echo $mem->get("mystr");
	
		$mem->add("myarr",array("aaa","bbb","ccc"));
		print_r($mem->get("myarr"));

		$mem->add("myobj",new PDOException);
		var_dump($mem->get("myobj"));

		echo $mem->getVersion();

		$mem->delete("mystr");
		$mem->flush();

		echo "<pre>";
		print_r($mem->getStats());
		echo "</pre>";

		$mem->addServer("www.ssl.com",11221);
		$mem->addServer("192.168.1.11",11211);
		
		$mem->close();

	在php什么地方使用memcache
		1、缓存数据库select出的数据
		2、在会话控制Session中使用

	key值注意：
		1、同一个项目安装两次，key要有不同的前缀
		2、同一个sql语句可能在不同页面重复使用，可使用sql的md5值做为key，或截取部分md5值作为key

	安全注意：
		1、内网访问
		2、设置防火墙
			iptables -A INPUT -p tcp -s 192.168.1.111 -dport 11211 -j ACCEPT
			iptables -A INPUT -p udp -s 192.168.1.111 -dport 11211 -j ACCEPT


基于Cookie的会话控制

	借助客户端电脑的一个文件来保存用户信息，再访问同一个网站的各个页面斗会带这些信息过去，服务器通过这些信息就能区分用户。

	cookie通过http头信息传递，因此设置cookie前不能有任何输出

	写入cookie
		$time=time()+3600;
		setCookie("one","111",$time);

	cookie中也可保存数组
		setCookie("arr[0]","111",$time);
		setCookie("arr[1]","222",$time);
		setCookie("arr['x']","333",$time);
		setCookie("arr['y']","444",$time);

	删除cookie
		$time=time()-1;
		setCookie("one");
		setCookie("two","",$time);

	读取cookie
		print_r($_COOKIE);
		print_($_COOKIE["one"]);


使用Session进行会话控制

	两种session：
		使用cookie保存sessionid 
		url中带有sessionid

	开启session：session_start();
		分配sessionid给客户端，基于cookie的session则写入了cookie中
		证明：echo $_COOKIE["PHPSESSIONID"];
		因此基于cookie的session，在此语句前不能有任何输出
		php配置文件中开启session：session.auto_start=1，则所有页面不用写session_start();但这种方式限制是不能将对象放入session中，因此不建议使用


	保存数据到session
		$_SESSION["aa"]="111";

	读取session
		echo $_SESSION["aa"];
		echo $_SESSION[session_name()];

	获取sessionid
		echo session_id();

	注销session
		也先要开启session：
			session_start();

		删除session数组中某个值：
			unset($_SESSION["aa"]);
				不要unset($_SESSION);

		清空session：
			$_SESSION=array();

		清除cookie中的sessionid：
			isset($_COOKIE[session_name()]){
				setCookie(session_name(),'',time()-1,'/'); //路径参数不可少
			}

		彻底销毁session
			session_destroy();

	URL中传sessionid

		方案1：指定url中传sessionid的变量

			if(isset($_GET["sid"])){
				session_id($_GET["sid"]);
			}
			session_start();

			echo "<a href='/index.php?sid={session_id()}'>首页</a>";

		方案2：url中使用session_name()传sessionid

			echo "<a href='/index.php?{session_name()}={session_id()}'>首页</a>";


		方案3：使用常量SID
			浏览器支持cookie则值为空
			不支持cookie则代表了session_name和session_id的值

				echo "<a href='/index.php?{SID}'>首页</a>";

		方案4：修改配置文件，使得链接自动增加sessionid，表单、链接、header跳转前都会自动增加，但？？？echo输出的链接、客户端脚本中的跳转系统检测不到？？？，需要自己添加

			session.user_trans_sid = 1

SESSION的高级用法将信息写入到自定义文件

	一、session信息写入到自定义位置

		1、解决跨机保存session
			文件系统：linux下可以使用nfs或是samba，windows下使用共享文件夹

			使用数据库

			使用memcache

			上述都需要使用函数session_set_save_handler()来实现

		2、解决在线用户信息

	二、php配置文件中的常用选择

		session.name
		session.use_trans_sid
			启用SID的支持，默认值为0
		session.save_path
			session文件保存位置，session文件以sess_开头，后面是sessionid

		session.use_cookies
		session.cookie_path
		session.cookie_domain
		session.cookie_lifetime
			保存到客户端的cookie的最长时间
			默认值为0，表示关闭浏览器就删除
			设置此值后，即使用户未关闭浏览器，到时也会删除老cookie，产生新cookie

		session.save_handler
			默认值为files
			自定义位置改为：user
			保存到memcache改为：memcahe

		session.gc_maxlifetime
			gc是garbage collection垃圾回收的缩写
			指定经过多少秒后数据被视为垃圾并被清除
			用户有动作时，session_start会重新设定此时间？？？
			默认是1440秒
		session.gc_probability
			默认值1
		session.gc_divisor
			默认值100
			上面两个函数合起来使用，用于gc进程启动概率：session初始化时，即调用session_start()时，会启动垃圾回收进程来回收垃圾session，但并非超时的session这时一定被清除，因考虑到性能问题，是否清除session有个概率，即上面两值相除，如按默认值为1%。

	三、session_set_save_handler()函数的使用

		修改php配置文件：session.save_handler = user

		//在运行session_start()时调用
		//启动会话
		function open($save_path,$session_name){
			global $sess_save_path;
			$sess_save_path = $save_path;
			return true;
		}

		//在调用session_write_close和session_destroy时调用
		function close(){
			return true;
		}
	
		//在运行session_start()和读取数据$_SESSION时
		//读取session数据到$_SESSION中
		function read($session_id){
			global $sess_save_path;
			$sess_file=$sess_save_path."mysessfile".$session_id;

			return (string)file_get_contents($sess_file);
		}

		//结束时和session_write_close()强制提交session数据时
		function write($session_id,$sess_data){
			global $sess_save_path;
			$sess_file=$sess_save_path."mysessfile".$session_id;

			if($fp=fopen($sess_file,"w")){
				$return=fwrite($fp,$sess_data);
				fclose($fp);
				return $return;
			}else{
				return false;
			}

		}

		//调用session_destroy();时
		//
		function destroy($session_id){
			global $sess_save_path;
			$sess_file=$sess_save_path."mysessfile".$session_id;

			return unlink($sess_file);
		}

		//在session.gc.probability和session.gc_divisor值决定的，在open()、read()、session_start()时
		function gc($gc_maxlifetime){
			global $sess_save_path;
			
			foreach(glob($sess_save_path."/mysessfile_*") as $filename){
				if(filemtime($filename)+gc_maxlifetime<time()){
					unlink($filename);
				}
			}
		}

		session_set_save_handler("open","close","read","write","destroy","gc",); //参数均为回调函数

		session_start();


SESSION的高级应用将信息写入到数据库中（*******自己实现一遍******）

	给回调函数传值，当函数没有类中时，直接传函数名就可以
	当函数在类中时，需要使用数组，第一个元素为类名，第二个元素为方法名

	__class__常量代表类名


SESSION最优的应用将信息写入到Memcache中管理（*******自己实现一遍******）

	memcache中set方法设置的时间可以完成session的gc完成的而工作，因此gc直接返回true

	即使不自己实现session_set_save_handler的各回调方法，仅修改php配置文件也可实现：
		session.save_handler = memcache
		session.save_path="tcp://192.168.1.11:11211","tcp://192.168.1.12:11211"


Ajax介绍和引擎对象的创建

	什么是Ajax
		需要有Javascript和DOM的基础
		Ajax（Asynchronous Javascript and XML)
		采用异步交互过程

	Ajax优缺点
		按需求数据，减轻服务器负担
		减少用户等待时间，优化用户体验

		需要测试对各浏览器的兼容性
		后退功能失效
		流媒体不能很好支持
		嵌入式设备不能很好支持，如手机


	Ajax应用
		局部刷新

	创建Ajax对象
		为兼容各浏览器，创建对象稍复杂，但代码是固定的
		将创建XMLHttpRequest对象的过程写到一个函数中
		将浏览器分成两种：
				IE系列：ie5,ie5.5,ie6,ie7,ie8
				非IE系列：都是按W3C标准 firefox mozilla opera

		function createAjax(){
			var request=false;
			
			//window对象中有XMLHttpRequest则是：ie7、ie8或非ie浏览器
			if(window.XMLHttpRequest){
				alert("ie7、ie8或非ie浏览器");

				request=new XMLHttpRequest();

				//有的浏览器需要重载MIME类型
				if(request.overrideMimeType){
					request.overrideMimeType("text/xml");
				}
			}

			//window对象中友ActiveXObject即是IE的低版本
			if(window.ActiveXObject){
				alert("IE的低版本");

				//不同版本有不同参数
				ver versions=['Microsoft.XMLHttp','MSXML.XMLHTTP','Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0','Msxml2.XMLHTTP.4.0','MSXML2.XMLHTTP.3.0','MSXML2.XMLHTTP'];

				for(var i=0;i<version.length;i++){
					try{
						request=new ActiveXObject(version[i]);
						if(request){
							return request;
						}
					}catche(e){
						request=false;
					}
				}
			}

			return request;
		}


使用Ajax对象中的属性和方法完成对服务器的请求和响应

	请求是使用ajax对象的方法实现，接收返回是使用Ajax对象的属性实现。

	6个属性：
		onreadystatechange	状态改变的事件触发器
		readyState		对象状态
					0=未初始化 1=读取中 2=已读取 3=交互中 4=完成
		responseText		服务器返回数据的文本版本
		responseXML		服务器返回数据的兼容DOM的XML文档对象
		status			服务器返回的状态码，如：404=文件未找到 200=成功
		statusText		服务器返回的状态文本信息

	6个方法：
		getAllResponseHeaders()：以字符串返回完整头信息
		getResponseHeader("headerlabel")：以字符串返回单个的header标签
		setRequestHeader("label","value")：设置header并和请求一起发送
		
		open("method","URL"[,asyncFlag[,"userName"[,"password"]]])：设置请求参数
		send(content)：发送请求
		abort()：停止当前请求

	//注意：每次请求都要使用一个新的XMLRequest对象
	var ajax=null;

	function show(){
		ajax=createAjax();
		ajax.onreadystatechange=function(){
			if(ajax.readyState==4){
				if(ajax.status==200){
					alert(ajax.responseText);
				}else{
					alert("页面请求失败");
				}
			}
		}	
		ajax.open("get","server.php?key=value&"+math.random(),true); //get直接通过url传数据
		ajax.send(null);

		//上面普通文本，下面xml文档对象

		ajax-createAjax();
		ajax.onreadystatechange=function(){
			if(ajax.readyState==4){
				if(ajax.status==200){
					var dom=ajax.responseXML;
					var users=dom.getElementByTagName("user");
					alert(users.length);
				}else{
					alert("页面请求失败");
				}
			}
		}	
		ajax.open("post","server.php",true);
		ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");//指定传输编码
		ajax.send("key=value&"+math.random());
	}

	注意：有中文时，为防止乱码，最好在服务器返回信息时设置header：
		header("Content-Type:text/html;charset=utf-8");

	服务器端返回json编码：
		echo json_encode(array("one"=>"111","two"=>"222"));

	客户端处理json编码：
		eval("var obj=" + ajax.responseText);
		alert(obj.one);
		alert(obj.two);

自定义对象简化Ajax的操作（*******自己实现一遍******）

	function Ajax(type){
		var ajax = new object();

		ajax.get = function(){

		}

		ajax.post = function(){

		}
	}


使用Ajax实现无刷新分页

	为ajax取过的数据增加客户端缓存


PHP模板技术介绍及自定义模板引擎

	Smarty模板引擎只是使用php开发的一个项目

	使用模板引擎的php程序的流程：用户访问php程序---》php程序里加载模板引擎---》php程序传递变量给模板引擎---》模板引擎加载模板---》模板引擎替换模板中的标识---》模板引擎创建编译好的文件---》模板引擎输出编译好的文件


Smarty介绍安装及配置

	使用smarty程序员需要做：	
		1、php程序和原来一样
		2、增加加载Smarty引擎，并创建对象
		3、为引擎分配php程序变量
		4、为引擎传递模板参数并显示


	使用smarty美工需要做：	
		1、制作html页面
		2、使用Smarty表现逻辑、放变量、遍历和判断数据

	安装
		下载Smarty压缩文件包，解压后将lib目录解压到网站目录下，包含lib目录下Smarty.class.php

		include "./lib/Smarty.class.php";

		$title="this is my title";
		$content="this is my title";

		$tpl=new Smarty();
		$tpl->assign("title",$title);
		$tpl->assign("content","$content");
		$tpl->display("mytemplate.tpl);

	初始化

		$tpl->template_dir="./tpl";	//模板目录
		$tpl->compile_dir="./com";	//编译目录
		$tpl->left_delimiter="<{";	//定界符，默认定界符{}和css、javascript的函数等冲突 $tpl->right_delimiter="}>";

	注意事项
		1、访问的是php文件，而模板是php文件包含的，所以模板中的图片、css文件、js文件路径都要以php文件为准
		2、php程序向模板引擎传递模板路径和名称时，以及模板包含其他模板时，等等所有的模板路径都要以Smarty中设定的模板目录template_dir为基目录
		3、如果想让各个目录下的php程序都可以加载Smarty和使用Smarty指定的模板和编译目录，唯一办法就是使用绝对路径。（注意：不同于asp，/代表网站根目录只是相对于客户端来说，对php来说/代表系统根目录）

		define("Root","C:/AppServ/www/");    //define("Root",$_SERVER["SCRIPT_FILENAME"]);
		include Root."libs/Smarty.class.php";
		$tpl=new Smarty();
		$tpl->template_dir=Root."tpl/";
		$tpl->compile_dir=Root."com/";

在Smarty中使用变量

	注释:<{* *}>，像php注释一样，不会输出到客户端

	Smarty是以变量为主的，所有的访问方式都是基于变量的，有三种变量使用方式：

	一、php程序中为模板引擎分配变量

		php从数据库或文件以及通过算法生成的动态数据

		任何类型的数据都可从php分配过来：

			标量：string int double boolean
			
			复合：array object NULL

			注意：  索引数组在模板中和php中使用方式相同，都是 数组名[索引下标]

				但关联数组在模板中不是使用 数组名["下标名"]的方式使用，而是使用 数组名.下标名 的方式

			模板中的变量可以进行运算：+ - * /

	二、在模板配置文件中给模板变量

		和模板的界面设计相关的变量

		配置文件：为键值对的形式
			border=1
			bgcolor=yellow	//公用变量，包含此配置文件后即可使用变量<{#bgcolor#}>

			[one]
			aa=111		

			[two]		//[] 设置了区域变量
			bb=222

			[three]
			cc=333		//包含配置文件时，使用section指定区域<{config_load file="view.conf" section="one"}>然后才可以使用此区域中变量<{#aa#}>

		配置文件的公用变量一般存放各页面都要用到的配置信息，而区域变量分别包含一级、二级、三级页面的不同配置信息

		使用步骤：

		1.修改Smarty属性，指定模板配置文件的目录：
			$tpl->config_dir=Root."config";

		2.模板中导入配置文件：
			<{config_load file="view.conf"}>

		3.模板中使用配置文件变量:
			<{#配置文件变量名#}>  <{  #配置文件变量名#  }> #号是和变量名紧挨着
			或
			<{$smarty.config.配置文件变量名}>


	三、模板保留变量


		1、模板提供了对超全局数组的直接访问，免去php程序再传值的麻烦：

			<{$smarty.get.page}> 		等价于php程序 $_GET["page"]
			<{$smarty.post.page}> 		等价于php程序 $_POST["page"]
			<{$smarty.request.page}> 	等价于php程序 $_REQUEST["page"]

			<{$smarty.cookie.page}> 	等价于php程序 $_COOKIE["page"]
			<{$smarty.session.username}> 	等价于php程序 $_SESSION["username"]

			<{$smarty.server.SERVER_NAME}> 	等价于php程序 $_SERVER["SERVER_NAME"]
			<{$smarty.env.PATH}> 		等价于php程序 $_ENV["PATH"]

			$_FILES		无对应
			$GLOBALS	无对应

		2、常量的使用方式

			php中用户自定义常量：
				define("ROOT","c:/myapp/www");
			
			模板中可直接使用常量，无需php程序传递：
				<{$smarty.const.ROOT}>

			模板中也可直接使用系统常量：
				<{$smarty.const.__FILE__}>

		3、时间
			<{$smarty.now}>

		4、
		5、
		6、


在Smarty模板中使用自定义函数

	html标签可分为单标签和块标签，单标签如：<input type="text" name="user">，块标签如：<font color="red" size="7"></font>，块标签有结束标记。

	Smarty模板中的自定义函数也可实现单标签和块标签，分别对应于注册函数和注册块。

	一、函数使用方式1：注册函数

		因Smarty是以变量为主的，在Smarty中调用php函数，其实是以自定义标记的形式来使用，类似于html标记

		1、php中编写函数，要求函数的参数只有一个，且参数类型为关联数组

			function demo(array $arr){
				echo $arr["id"];
				echo $arr["name"];
				echo $arr["price"];
			}

		2、php中模板引擎注册此函数，并给出模板中的调用名字

			$tpl->register_function("demo","hello");

		3、模板中按模板标签的形式使用此函数，关联数组的下标为属性名，即：

			<{函数名 关联数组下标1=下标所对应的值  关联数组下标2=下标所对应的值  关联数组下标3=下标所对应的值}>

			<{hello id="1" name="zhangsan" price="11"}>

		其实，Smarty模板中的include文件和load_config就是注册函数的使用方式：

			<{include file="header.tpl"}>

			<{load_config file="view.conf" section="homepage"}>

	一、函数使用方式2：注册块
		
		1、php中编写函数，函数的参数为4个
			参数1：关联数组
			参数2：块中的内容
			参数3：引用传值，&$smarty
			参数4：引用传值，$smarty会调用

			function test($arr,$content,&$smarty,&$smartycall){
				echo $arr["id"];
				echo $arr["name"];
				echo $arr["price"];
				echo $arr["content"];
			}

		2、php中模板引擎注册块，并给出模板中的调用名字

			$tpl->register_block("world","test");

		3、模板中按模板标签的形式使用此函数，关联数组的下标为属性名，即：

			<{函数名 关联数组下标1=下标所对应的值  关联数组下标2=下标所对应的值  关联数组下标3=下标所对应的值}>

			<{world id="1" name="zhangsan" price="11"}>
				这里的内容会传给第二个参数	
				这里也可以使用php变量，如<{$var}>,当然这个变量需要php传递过来：$tpl->assign("var",$myvar);
			<{/world}> 

		其实，Smarty模板中的if就是注册块的使用方式：

			<{if $isTrue}>
				welcome,haha
			<{else}>
				no,sorry
			<{/if}>

	上述两种方式，即注册函数和注册块
		1、都可以在注册函数标签字符串或注册块标签字符串的属性中使用php变量，当然需要先传递值
		2、变量做属性，不能加引号
		3、但双引号中也可以使用php变量，但此变量只能保护字母，数字，下划线和中括号，若包含其他字母则要使用``括起来，如关联数组在引号中使用时，需要使用``括起来，`$arr.one`否则会原形输出：
		4、属性中还可以使用配置文件读取过来的变量，用##括起来的，综合实例：
		
			<{hello id="1" name="zhang $haha san" price=$price color=#color#}>
		
			<{world id="1" name="zhang $haha san" price=$price color=#color#}>
				这里的内容会传给第二个参数	
				这里也可以使用php变量，如<{$var}>,当然这个变量需要php传递过来：$tpl->assign("var",$myvar);
			<{/world}> 


	二、Smarty插件功能

		smarty的plugins是插件目录，可以定义函数和块和变量调节器

		plugins目录下文件的命名规范：

			function开头的为函数
			block开头的为块函数	+.【函数名】+.php，如function.hello.php
			modifier开头的为变量调节器

		函数文件规范：

			函数以smarty_function_开头
			块函数以smary_block_开头	+【函数名】，如function smarty_function_math($params,&$smarty)
			变量调节器以smarty_modifier开头

		上述两个的【函数名】和模板中调用的函数名<{【函数名】 id="" name=""}>是一样的，则函数会被自动调用，不再用注册	
	

	Smarty的自定义函数：

		Smarty的plugins目录下的函数均为自定义函数，可自由修改，Smarty还有内建函数，是写在Smarty内部的，不可修改


使用Smarty中的变量调解器

	如果没有变量调节器，则同一个字符串，使用原形，小写字符串，部分字符串时，则需要多次在php中处理好后再多次传递

	在Smarty模板文件中，在变量后面使用 | 加函数名，这个函数第一个参数就是这个变量，以后每个参数直接使用冒号分隔：

		<{$var|myfunction:param1:param2}>

		<{$var|myfunction:"strtoupper"}>

		变量调节器也可以进去组合，称为组合变量调节器，如字符串先转换为大写，再截取：

			<{$var|strtoupper:param1:param2|substring:param1:param2}>

	变量调节器在plugins目录下文件的命名规范：

		modifier.方法名.php

	函数规范：

		变量调节器函数以smarty_modifier开头，后面是方法名，第一个参数为调用此函数的字符串

		function smarty_modifier_myfunction($str,$ope){

		}

		系统提供的变量调节器：

			truncate 截取中文会导致乱码，utf-8和gb2312有不同的截取方式


使用Smarty中提供的内建函数

	内建函数和自定义函数的用法相同，都是使用标记

	自定义函数可以通过注册和插件方式，加入自己的函数到smarty中，相当于扩展

	系统提供的自定义函数可以改，可以删

	Smarty内部的函数只能按手册提供的方式使用，不可以改，也不可以删除

	流程控制if，数组的遍历，文件包含，配置文件导入都要使用内建函数

	include和assign：
		通过assign为模板引擎传递变量时，被include的子模板也可以使用此变量，子模板还可再包含子模板，也可使用变量。

	capture:将capture块直接的输出存到变量里，不输出到页面上

		<{capture name="output"}>
			<hr><span>asdf</span>
			<{$var}>	
		<{/capture}>

		<{$smarty.capture.output}>

	if语句：

		<{if $var==1}>
		<{elseif}>
		<{elseif}>
		<{else}>
		<{/if}>
		集合和php的if语句一样，但条件判断的符号很多

	foreach,foreachelse
		和php的foreach用法相同，如果遍历的数组为空，则执行foreachelse

		<{foreach from=$arr item="val" key="k" name="one"}> //name是为循环起的名字
			<{$smarty.foreach.one.literation}>---<{$k}>---<{$val}>
		<{foreachelse}>
			数组为空或没有分配过来
		<{/foreach}>

		这个循环共循环了<{$smarty.foreach.one.total}>次

	section,sectionelse

		和foreach一样，也是可以遍历数组的，但效率比foreach高，功能比foreach多，建议使用section处理数组

		foreach被编译成了php的foreach，而section被编译为了php的for循环，不用像foreach一样为每个变量赋值

		缺点是不能遍历关联数组，只能是索引数组，且是下标连续的

		<{section loop=$arr name="ls"}>
			<{$arr[ls]}>
		<{sectionelse}>
			数组为空
		<{/section}>

使用Smarty中的强大缓存技术

	0、判断是否被缓存

		isCached("test.tpl",$_SERVER["REQUEST_URI"]);

	1、开启缓存
		$tpl->caching=0; //开发阶段不要开启，运行阶段再开启	

	2、指定缓存更新时间
		$tpl->cache_lifetime=60*60*24*7

	3、指定缓存文件保存位置
		$tpl->cache_dir=ROOT."cache";

	4、指定缓存ID

		一个模板只能有一个缓存文件，如果一个模板有多个文章，则需要每个文章有一个缓存

		$tpl->display("test.tpl",cacheid);

		cacheid每次变化一个值就会有一个缓存，最好使用url作为cacheid: $_SERVER["REQUEST_URI"]

	5、局部不缓存

		(1)、自己使用register_block的方式写一个<{nocahce}><{/nocache}>标签

			php程序：
				$tpl->register_block("nocache","notcache",false); //第三个参数即指明不缓存

				function notcache($param,$content){
					return $content;
				}

			Smarty模板：
				<{nocahce}>
					<font color=red><{$var}></font>
				<{/nocache}>
				
		(2)、使用插件块的方式

			文件名：block.nocache.php

			函数：
				function smarty_block_nocache($params,$content,&$smarty){
					return $content;
				}

			但默认所有的块都是缓存的，即使经过上面修改后，还不行，还需要修改smarty被编译后的类：

				打开libs目录下的Smarty_Compiler.class.php

				大概713行附近
					$this->_plugins['block'][$tag_command]=array($plugin_func,null,null,null,true);
				修改为：
					if($tag_command=="nocache")
						$this->_plugins['block'][$tag_command]=array($plugin_func,null,null,null,false);
					else
						$this->_plugins['block'][$tag_command]=array($plugin_func,null,null,null,true);

	6、清除缓存

		clearCache
		clearAllCache


MVC设计模式及PHP框架介绍
	
	M:model，指业务模型
	V:view，指用户视图
	C:control，指控制器，用来处理用户动作，通过动作来完成视图的显示和业务的调度

	模块：不要和模型混淆，模块可以理解为一个独立应用

	操作：指模块可能有的动作，如用户模块的操作有：添加用户、修改用户、删除用户等

	框架：是一个半成品，提取了多个项目都需要用到的模块，可以完成一个项目50%左右的工作量

	框架应具备的功能：
		目录组织结构
		类加载
		基础类
		强制MVC
		URL处理
		输入处理
		错误异常处理
		扩展类

	流行php框架：
		YII		推荐
		ZendFramework	php官方框架，使用和学习都很麻烦，不建议使用

	自己开发框架原因：
		安全
		按需定制


BroPHP框架介绍及目录部署


BroPHP框架的控制器声明与应用

	url采用pathinfo模式，这种模式对搜索引擎兼容性比较好

	http://host/入口文件名/模块名/操作/参数名1/值1/参数名2/值2

	默认模块为index，默认操作为index

	模块对应control目录下同名的文件里的同名的类，一个操作对应类中一个方法

BroPHP框架中模型的声明与应用


BroPHP框架中数据库的统一操作接口


BroPHP视图的声明与应用


BroPHP框架中的自动验证


BroPHP框架内置扩展类库和自定义扩展类


BroPHP框架的综合应用实现用户注册和登录


BroPHP框架的综合应用实例一个完整模块的操作过程

