引用
---------

		在 PHP 中，变量名和变量内容是不一样的，变量已经不再保存整个对象的值，只是保存一个标识符来访问真正的对象内容。
		同样的对象内容可以使用不同的标识符。PHP 的引用即是两个不同的变量名字指向相同的内容，php的引用是别名，
------------------
2.PHP5默认的参数传递就是值传递，如果传递的是对象，那么其实是拷贝了这个对象的一个指针（“标识符”），在使用“->”操作符的时候自然操作的是对象本身，而使用"="的时候，则是赋值给这个拷贝的指针，不会影响实际对象。（这里其实说的是PHP的默认赋值其实一直都是值传递，任何情况下！只是对象的表象产生了迷惑，不是引用传递，而是引用拷贝！）
3.”&“才会创建一个对象的永久的引用，一旦创建这种关系，想解除，就只能用unset()函数！（这里我理解的还是上文我提到的那种关系！）
---------------------
当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容

在php5 的对象编程经常提到的一个关键点是“默认情况下对象是通过引用传递的”。但其实这不是完全正确的。下面通过一些例子来说明。 

php的引用是别名，就是两个不同的变量名字指向相同的内容。在php5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。 

class A {
    public $foo = 1;
}  

$a = new A;
$b = $a;     // $a ,$b都是同一个标识符的拷贝
             // ($a) = ($b) = <id>    
$b->foo = 2;
echo $a->foo."\n";


$c = new A;
$d = &$c;    // $c ,$d是引用，互为引用
             // ($c,$d) = <id>

$d->foo = 2;
echo $c->foo."\n";


$e = new A;

function foo($obj) {
    // ($obj) = ($e) = <id>
    $obj->foo = 2;
}

foo($e);
echo $e->foo."\n";






		class AAA{
			public $str = 'AAA';
		}

		$a = new AAA;
		$b = $a;
		$r = &$a;

		echo $a->str.'<br>';
		echo $b->str.'<br>';
		echo $r->str.'<br>';
		$b->str = 'BBB';
		echo $a->str.'<br>';
		echo $b->str.'<br>';
		echo $r->str.'<br>';

		$a = null;
		var_dump($a);
		var_dump($b);
		var_dump($r)

		输出：

		AAA
		AAA
		AAA
		BBB
		BBB
		BBB
		null
		object(AAA)[1]
		  public 'str' => string 'BBB' (length=3)
		null
???
如果具有引用的数组被拷贝，其值不会解除引用。对于数组传值给函数也是如此。 


