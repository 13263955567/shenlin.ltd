类型
-----
	PHP的变量类型是PHP根据该变量使用的上下文在运行时决定的。

	PHP支持8种基本数据类型，其中包括4种标量类型，2种复合类型，2种特殊类型。

4种标量类型

		boolean 布尔型

			关键字true和false不区分大小写

			强制转换：使用(bool)或(boolean)

			自动转换：当运算符、函数或流程控制结构需要一个boolean参数时，值会自动被转换。

			转换为boolean时，下列值被认为false，其他值均为true：
				布尔值false本身
				整型0
				浮点型0.0
				空字符串 和 字符串'0'	注意没有字符串'0.0'
				空数组					注意不包含空对象，空对象表示false只适用于PHP4.0
				NULL
				从没有任何标记的XML文档生成的SimpleXML对象

			和empty是反义词

			比转换为null多一个字符串'0'

			???空对象测试失败

		integer 整型

			可以用十进制、十六进制、八进制表示，前面可加符号+ -
			八进制表示时数字前加零0，如果向八进制传递了一个非法数字如9，则后面的其余数字会被忽略
			十六进制表示时数字前加0x

			十进制正则表示：[+-]?[1-9][0-9]*|0
			八进制正则表示：[+-]?0[0-7]+
			十六进制正则表示：[+-]?0[0-7]+
			整型正则表示：

			PHP不支持无符号整数
			整型字长和平台有关，可以使用常量PHP_INT_SIZE获取字长
			4个字节计算，最大值为21亿多(2147483647)，可以使用常量PHP_INT_MAX获取最大值

			整数溢出：
					给出的数或运算结果超出了整型范围，将会被解释为float
								var_dump(2147483647);
								echo "<br>";
								var_dump(2147483648)
			自动转换
					当运算符、函数或流程控制结构需要一个integer参数时，值会自动被转换。

			强制转换
					使用(int) (integer) intval()

			其他类型转换为整型：
					从布尔型：
							false 转为 0  true 转为  1
					从浮点型：
							浮点型转为整型，将向0取整。
								echo (int)(-3.9);	//返回-3
								echo (int)(3.9);	//返回3
								echo intval(-3.9);	//返回-3
								echo intval(3.9)	//返回3

							不要将未知的分数强制转换为整型，会导致不可预料的结果
								echo (int)((0.7+0.1) * 10);		返回7
					从字符串型：
							当字符串被用在了数字的环境中，则会被自动转为数字处理

							是否可成功转为数字处理的条件：
									字符串以符号+-或数字开始，后面跟着可选的小数点和指数符号e或E，后面又是数字，则是一个合法数值，则数值可直接使用，否则值是0
									

							转为整型还是浮点型的判定条件：
									满足转为数字处理的条件后，
									字符串不包含 '.' 'e' 'E' 且数值符合整数类型的限定，则被作为整型处理
									否则作为浮点型处理

					除了上述3种类型可转换为整型，没有定义其他类型转换为整型的行为。不要使用未被定义的其他转换行为，因为可能会被改变而不进行通知。

		float 浮点型

			也称为双精度数或实数，可以用. e E来定义
				$a=1.234;
				$b=1.2e3;
				$c=7E-10;
			浮点数的字长和平台相关，通常最大值为1.8e308，为14位长的十进制数

			关于floor((0.1+0.7)*10)返回7的说明：浮点数精度的警告

				不可能用有限的二进制位数精确的表达某些十进制分数，如十进制的1/3，所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等，如果确实需要更高地精度，应该使用 任意精度数学函数BC Math 或 gmp函数

			转换为浮点数
				字符串转换为浮点数参考整型的说明
				其他类型的值转换为浮点数，则情况类似为先将值转换为整型，在转换为浮点型

		string 字符串
			
			PHP中，一个字符占一个字节，一个字节只能有256种变化，因此PHP无法原生支持Unicode

			字符串由一系列的字符组成，长度只受限于服务器内存

			定义字符串4种方法：单引号、双引号、hereDoc语法结构、newDoc语法结构，其中双引号和hereDoc定义的字符串中的变量和特殊字符会被解析

			单引号
				单引号中的特殊字符和变量不会被解析
				在输出单引号和\时，需使用\做转义，其他任意符号前加了\做转义则会原样输出\

			双引号
				双引号中的特殊字符会被解析，列表：
					\n		换行
					\r		回车
					\t		水平方向tab
					\v		垂直方向tab
					\f		换页
					\\		反斜线
					\$		美元标记
					\"		双引号
					\[0-7]{1-3}	复合此表达式的字符串是一个八进制的字符，如"\123"
					\x[0-9A-Fa-f]{1,2}	复合此表达式的字符串是一个十六进制的字符，如"\x41"

				双引号中的变量会被解析，详细看下面的变量解析

			hereDoc语法结构

				格式和描述：

						<<<EOT						//<<<为规定字符，前面可以有其他字符，如echo
													//EOT为自己定义的标识符，PHP5.3.0以后也可以使用双引号括住标识符
							..........
							字符串本身				//字符串需要写在新行中
							..........

						EOT;						//前面自己定义的标识符
													//必须在一行的最开始位置，前面不能任何空白
													//分号的后面也不能有空白，不能有任何字符
													//分号和标识符之间也不能有任何空白
						
						不遵守hereDoc的语法规则会导致标签不干净，产生一个语法错误

				解析：	
						Heredoc就像是没有使用双引号的双引号字符串，双引号中可被解析的特殊字符、变量也会被解析，但输出双引号时无需使用\转义了

				用处：
						hereDoc结构可以作为函数参数来传数据
						PHP5.3之后，可以使用hereDoc结构来初始化静态变量和类的属性和常量，但不能在类的heredoc结构中使用变量

				PHP4版本引入heredoc

			nowDoc语法结构

				格式和描述：
					
						和heredoc几乎一样，唯一的区别是开始处的标识符需要使用单引号括起来，即

						>>>'EOT'

							字符串

						EOT;

				解析：	

					和使用单引号的字符串一样，只是单引号不需要做转义

				用处：

					不需要转义的PHP代码和其他大段文本

					用在任意的静态数据环境中，如初始化类的属性和常量

				PHP5.3.0版本引入nowdoc

			变量解析

				使用双引号和heredoc定义的字符串，变量将会被解析，解析规则有两种：简单句法规则和复杂句法规则。
				两者的区别不是结构复杂度，而是后者可以使用复杂的表达式。

				规则：
					当PHP解析器遇到一个美元符号$，就去尽量形成一个合法的变量名，但如果变量名和一个合法的变量名组成元素紧靠在一起，则无法明确变量的界限，导致去解析不存在的变量，引发notice错误，因此当遇到这种情况时，需要使用花括号{}来明确标定变量名的界限。{无法被转义，所以$要紧挨着{。
						$beer = 'Heineken';
						echo "$beer's taste is great"; 	//有效；单引号"'"是非法的变量名组成元素
						echo "He drank some $beers"; 	//无效;字母s是有效的变量名组成元素，但是这里的变量是$beer
						echo "He drank some ${beer}s"; 	//有效
						echo "He drank some {$beer}s"; 	//有效
					$符号后是空格的话则直接输出$符号，无错误，但若包含在{}中，{$后是空格则错误
					解析过程可分为两步：第一步是找到变量并取得值，第二步，是将值转换为字符串类型，如：	
						$bln=true;
						echo "$bln";
						输出：1并非true
					{}和数组
						1、数组下标使用[]界定范围
						2、数组下标的引号和{}一起出现，一起消失，即
								a、数组没有被{}括起来时，数组的字符串下标也不能使用引号括起来
								b、数组被{}括起来时，数组的字符串下标也必须被引号括起来，没有被括起来，则PHP会认为此字符串下标是一个常量，若搜不到此常量，则报notice级错误
					因此可以看出，使用了{}的语法更适合习惯，只需简单地像在字符串以外的地方那样写出表达式， 然后用花括号{和 }把它括起来就可以了。

					但{}中也有例外，如并不是所有的php语法都可以在{}中正常使用的：函数、行为、类的静态变量和类的常量只有在其返回值作为变量名时才可以使用，也就是说，在{}中无法直接调用函数，无法直接获取到类的常量值、静态变量值，下面的例子:

					注：要保证$始终在{}包围中，防止多次解析失败


						echo"定义变量:\$myvar = 123";
						echo "<br>";
						echo"定义变量:\$name = 'myvar'";

						$myvar = 123;
						$name = 'myvar';
						echo "<br>";


						//-------------------------------------------------------------


						echo "<br>-------------------<br>";
						echo "<b>在{\$}中调用变量</b>";
						echo "<br>-------------------<br>";

						echo "变量\$name的值{\$name}: {$name}";
						echo "<br>";
						echo "以变量\$name值为变量的值{\${\$name}}: {${$name}}";
						echo "<br>";


						//-------------------------------------------------------------


						echo "<br>-------------------<br>";
						echo "<b>在{\$}中调用函数</b>";
						echo "<br>-------------------<br>";

						function getName(){
							return 'myvar';
						}
						echo "以函数getName()返回值为变量的值{\${getName()}}:{${getName()}}";
						echo "<br>";

						//-------------------------------------------------------------

						echo "<br>-------------------<br>";
						echo "<b>在{\$}中调用函数，利用变量值返回''执行函数逻辑</b>";
						echo "<br>-------------------<br>";

						$funtest='';
						function funtest(){
							echo "这行是函数输出的内容，代表在执行函数逻辑...<br>";
							return 'funtest';
						}
						echo "调用函数{\${funtest()}}，但函数对应的变量值为''，则不会输出任何字符，却执行了函数逻辑：{${funtest()}}";
						echo "<br>";

						//-------------------------------------------------------------


						echo "<br>-------------------<br>";
						echo "<b>在{\$}中调用类的方法、属性、常量、静态变量</b>";
						echo "<br>-------------------<br>";

						class Demo{
							var $classVar = 'myvar';

							const classConst = 'myvar';

							public static $classStatic = 'myvar';

							function getName(){
								return 'myvar';	
							}
						}
						$object = new Demo;
						echo "
						获取对象的属性值
							<br>{\$object->classVar}: {$object->classVar}
						<br><br>
						调用对象的方法
							<br>{\$object->getName()}: {$object->getName()}
						<br><br>
						获取对象属性返回值所对应变量的值
							<br>{\${\$object->classVar}}: {${$object->classVar}}
						<br><br>
						获取对象方法返回值所对应变量的值
							<br>{\${\$object->getName()}}: {${$object->getName()}}
						<br><br>
						获取类常量值所对应的变量的值，注：获取不到类的常量值
							<br>{\${Demo::classConst}}: {${Demo::classConst}}
						<br><br>
						获取类的静态变量值所对应的变量的值，注：获取不到类的静态变量值
							<br>{\${Demo::\$classStatic}}: {${Demo::$classStatic}}
						";

						============输出如下==========================

						定义变量:$myvar = 123
						定义变量:$name = 'myvar'

						-------------------
						在{$}中调用变量
						-------------------
						变量$name的值{$name}: myvar
						以变量$name值为变量的值{${$name}}: 123

						-------------------
						在{$}中调用函数
						-------------------
						以函数getName()返回值为变量的值{${getName()}}:123

						-------------------
						在{$}中调用函数，利用变量值返回''执行函数逻辑
						-------------------
						这行是函数输出的内容，代表在执行函数逻辑...
						调用函数{${funtest()}}，但函数对应的变量值为''，则不会输出任何字符，却执行了函数逻辑：

						-------------------
						在{$}中调用类的方法、属性、常量、静态变量
						-------------------
						获取对象的属性值 
						{$object->classVar}: myvar 

						调用对象的方法 
						{$object->getName()}: myvar 

						获取对象属性返回值所对应变量的值 
						{${$object->classVar}}: 123 

						获取对象方法返回值所对应变量的值 
						{${$object->getName()}}: 123 

						获取类常量值所对应的变量的值，注：获取不到类的常量值 
						{${Demo::classConst}}: 123 

						获取类的静态变量值所对应的变量的值，注：获取不到类的静态变量值 
						{${Demo::$classStatic}}: 123


			存取和修改字符串中字符
				可以把字符串想象为数组，使用数组下标的方式来查找和修改单个字符$str[2]
						也可以使用{}，即$str{2}，但PHP5.3.0不推荐使用这种格式
						非整数类型转换为整数类型
						数字超出范围将产生Notice错误
						负数将产生Notice错误

			字符串操作符
				连接运算符 .
				连接赋值运算符 .=

			字符串函数
				*

			URL字符串函数
				*

			转换成字符串
				将PHP中各种类型的值转换为字符串来长期存储，这称为串行化，可以使用函数serialize()实现						
				强制转换：(string) strval() settype()

				布尔型转换为字符串
					true转为'1' false转为''

				整型和浮点型转换为字符串
					转换为字面样式的字符串，指数计数法也可以

				数组转换为字符串
					转换为字符串'Array'

				对象转换为字符串
					触发对应类的__toString

				资源转换为字符串
					转换为'Resource id #1'结构的字符串，其中1是PHP分配给该资源的独特数字

				NULL转换为字符串
					转为''

			
			字符串转变为数字
				参加整型的描述

			字符和数字之间转换
				获得字符的ASCII码
					int ord(string $string)
						虽然可传入字符串，但返回的是第一个字符的ascii码值

				获得对应ASCII码的字符
						string chr(int $ascii)

2种复合类型

		array
			映射是一种把values关联到keys的类型，PHP中的数组实际上是一个有序映射。
			可将PHP的有序映射当做真正的数组或列表（向量）、散列表、字典、集合、栈、队列
			PHP中索引数组和关联数组是相同的，都可以同时包含整型和字符串下标

			定义数组

				使用语言结构array()
					array(key=>value,value,.....)
						接受任意数量使用逗号分隔的键值对

				使用数组定义的短语法[]新建和修改数组
					$arr[key]=value;
					$arr[]=value;
					....
						$arr数组不存在时，则会新建
						如语法所示，也可以给出[]不给定键名

					一般是先将变量赋予空数组，再逐项赋值
							$arr=array();
							$arr[]=1;
							$arr[]=2;
							......

				关于value的说明
						value可为任意类型的值 

				关于key的说明
						key可以是整数（当然包含负整数）或字符串
						若key为字符串，但却是整数的标准表示，则会被解释为整数，如'8'将被解释为8，而'08'仍解释为'08'，因此不存在关联数组下标'8'和索引数组下标8同存于一个数组的情况
						key如果是浮点数则会转换为整数，即小数部分会被舍去，8.7被解释为8
						key是true，则转为1，key为false，转为0
						key为null，则转为空字符串''，该键的键名即是空字符串
						数组和对象不能作键名
						如果给出的值没有指定键名，则取当前最大的整数索引值+1作为键名，但如果当前的最大整数索引值为负数，则键名为0，或者还没有整数索引，则键名也是0
						注意数组最大的整数索引值不一定当前就在数组中，它只要在上次数组重新生成索引后存在过就可以，如一个数组最大为5，使用循环unset每个数组元素，则数组为空，当加入新元素后，其键从6开始，而不是0，原因是unset数组元素并不会使数组重新生成索引。
						如果指定的键名已存在值，则该值会被覆盖

	
			删除键值对
				对数组键值对使用unset()
				注意此操作并不会重建数组的索引

			删除数组
				对数组unset()

			转换到数组
				整型、浮点型、字符串、布尔值、资源类型转换为数组
						得到一个只有一个元素的数组，下标为0，值为此标量的值
				NULL转换为数组
						得到一个空数组
				对象转换为数组
						对象属性转换为数组，对象方法不处理 
						属性的变量名转换为键
							private变量会在变量名前加上类名作为键名，且在类名左右各加一个空字节\0
							protected变量会在变量名前加*，且在*号左右各加一个空字节\0
							public变量名不做变化

			引用传递改变数组的值

				PHP的变量默认总是赋值传值，数组也不例外，因此数组的赋值总是涉及到值的拷贝，可以使用引用赋值来避免值的拷贝

				$arr=array('red'=>'red color','green'=>'green color','blue'=>'blue color');	
				$colors=&$arr;						//第一次引用传值
				
				//新版本方法
				foreach($colors as &$color){		//第二次引用传值
					$color=strtoupper($color);
				}
				unset($color);						//防止下面使用到的$color始终指向数组最后一个元素

				//老版本方法
				foreach($colors as $key=>$color){
					$colors[$key]=strtoupper($color);
				}

				print_r($arr);
				print_r($colors);

			数组运算符

			数组函数
					array_values重建数组索引

			数组控制结构
					foreach专用于遍历数组

		object
			创建对象：
					使用new语句实例化一个类；

			转换为对象：
					使用(object)
					对象本身转换为对象，则无变化；其他类型的值转换为对象将会实例化一个内置类stdClass，如果类型是：
							NULL	空对象
										object(stdClass)[1]
							数组	索引数组的键转为属性，值转为属性值
									关联数组则转为没有标识符的标量值
										object(stdClass)[1]
										  int 3333
										  string 'wwww' (length=4)
										  boolean false
										  public 'a' => int 111
										  public 'b' => int 222
							其他	转为成员变量scalar的值
										object(stdClass)[1]
										  public 'scalar' => string 'asdf' (length=4)

2种特殊类型

		resource
			资源是一种特殊变量，保存了到外部资源的一个引用。
			资源是通过专门的函数来建立和使用的。

			其他类型转换为资源
				资源类型的变量保存的是打开文件、数据库链接、图形画布区域的特殊句柄，因此将其他类型的值转为资源没有意义

			释放资源
				PHP4 Zend引擎使用了引用计数系统，可以自动检测到一个资源不再被使用了，则此资源使用的所有外部资源都会被垃圾回收系统释放，因此很少需要手工释放内存。（持久化数据库链接比较特殊，不会被垃圾回收系统销毁）

			资源函数
				get_resource_type()
				is_resource()

		NULL
			只有一个值null，不区分大小写
			下列情况下，一个变量被认为是null
				未被赋值
				被赋值为null
				被unset()
			判断一个变量值是否为null时，$var===null比is_null($var)快
			空数组和null
				空数组和null使用==进行比较时，空数组会被转为null，结果返回true
				空数组和null使用===比较时，因类型不同，一个为数组类型一个为NULL类型，返回false
				空数组使用is_null判断时，is_null只判断是不是null值，不是返回false
			变量赋值为null和被unset()的区别：
				当一个变量$a被引用传值给变量$b时
					unset()其中任意一个变量，不影响另一个变量
						$a=123;
						$b=&$a;
						unset($a); 	//只影响$a
						var_dump($a);
						var-dump($b);
					将任意一个变量赋值为null，则同时影响另一个变量
						$a=123;
						$b=&$a;
						$a=null; 	//同时影响$a和$b
						var_dump($a);
						var_dump($b);
				被unset()后的变量会报Undefined Variable错误，但赋值为null后的变量则不会，如下列中的is_null和var_dump都是在判断不存在变量时会报错
					$a=123;
					$a=null;
					echo is_null($a);
					var_dump($a)

获取变量类型

		var_dump()
				查看表达式的值和类型

		gettype()
				获得一个易读懂的类型的描述字符串，方便调试使用

		is_type函数验证类型
				is_int
					别名is_integer
				is_float
					别名is_double、is_real
				is_numeric
					检测是否是数字 或 数字字符串

				is_bool
				is_string
				is_array
				is_object
				is_resource
				is_null
				
类型转换

		PHP在变量定义中不需要也不支持明确的类型定义；变量类型是根据使用该变量的上下文所决定的。

		自动类型转换

			自动转换为数组的行为没有定义

		强制类型转换

			在要转换的变量之前加上用括号括起来的目标类型。

			允许的强制转换有：
				
				4种标量：
				(int),(integer)
				(bool),(boolean)
				(float),(double),(real)
				(string)	没有想当然的(str)

				2种复杂：
				(array)
				(object)

				2种特殊中的1种（因资源类型没有强制转换）：
				(unset)		转换为NULL，注意不是使用(NULL)

				最后一个：
				(binary)	转换为二进制字符串，PHP6.0支持

				括号内允许有制表符、空格，即( int ) $bar;也没有错


		settype()函数

			bool settype(mixed $var,string $type)

				将变量$var的类型设置为$type
				成功时返回true，失败返回false

				$type的取值可以为（）：
					"bool","boolean"
					"int","integer"
					"float"			//double已停用
					"string"
					"array"
					"object"
					"null"

				和上面的强制转换几乎一一对应，少一个binary，null的转换不一样	

		将变量放置在双引号中的方式来代替将变量转换为字符串

			$foo = 10;
			$str = "$foo";			//正常处理应是$str=(string)$foo;但使用双引号的解析功能，"$foo"即被解析为变量$foo，且数据类型变为字符串
			$fst = (string)$foo;

			if($fst === $str){
				echo "they are the same";
			}

PHP类型比较表



伪类型
		并不是php的数据类型，只是为了在php手册中说明函数情况时，保证代码的易读性

		mixed
			说明一个参数可以接受两种以上的类型（含两种）

		number
			说明一个参数可以是integer或者float

		callback
			说明参数可以接收一个回调函数，回调函数可能是：
					1、PHP内置或用户自定义函数的函数名字符串
					2、对象的方法，传递形式为数组，下标0为对象变量，下标1为对象方法名字符串
					3、类的静态方法，传递形式为数组，下标0为类名字符串，下标1为类方法名字符串，如调用父类静态方法，则形式为'parent::方法名'
					4、create_function()函数创建的匿名函数
			注：不能是语言结构，如array()、echo()

		void
			作为返回类型意味着无返回值
			作为参数类型意味着不接受任何参数

伪变量$....
		表示等等的意思，表示函数可以接受任意个参数




【用户贡献笔记】

