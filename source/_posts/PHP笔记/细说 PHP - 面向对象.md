---
title: 细说 PHP - 面向对象
categories:
  - PHP
tags:
  - PHP
---

面向对象概述
		面向对象和面向过程的区别
			最小单位：函数
			最小单位：对象
		对象就是一个实体，一个东西
			成员属性==变量，定义对象外观和状态
			成员方法==函数，定义对象功能

类的声明
	[修饰类的关键字] class 类名{


	}

	1、一个文件只保存一个类
	2、文件名包含类名：类名.class.php，还可方便自动加载 
	3、成员属性和成员方法按驼峰命名法，第一个单词首字母小写，以后每个单词首字母大写
	   类名每个单词首字母大写 常量所有字母大写
	4、在类中声明成员属性时，前面必须有修饰词，当不知道用哪个时，就用var

类的实例化
	1、$对象实例=new 类名;
	2、对象中的成员必须通过对象实例来访问，使用符号->
		echo 对象实例->成员属性;
		echo 对象实例->成员方法;
		对象实例->成员属性=新值;
	3、对象内部成员的访问
		使用$this关键字，代表当前的对象实例

面向对象的构造与析构方法：

	构造方法：作用是为成员属性初始化
		  php4中和类名相同的方法就是构造方法，和正常的方法相同，也可以传参数，并为参数设默认值
		  php5中构造方法选择魔术方法__construct()，优点是在修改类名时不用改变构造方法名
		  php4和php5的两种构造方法可以共存，共存的必要是为了兼容php的不同版本

		class Person{
		
			var $name;
			var $age;
			var $sex;

			function Person($name,$age,$sex){
				$this->name=$name;	---->注意这里的name和$name，分别代表成员属性和构造方法的参数
				$this->age=$age;
				$this->sex=$sex;
			}
		}

		$p1=new Person("zhangsan",11,"boy");

	析构方法：对象释放之前最后一个自动调用的方法
		  作用是关闭一些儿资源，做一些儿清理工作，并非释放对象
		  java和PHP都是用垃圾回收器，而c++手动释放；
		  __destruct()
		  因为对象引用是保存在栈内存中的，而栈是后进先出，所以在系统自动释放对象时，是最后创建的对象最先释放
		  可以使用 $对象引用=null; 来提前手动释放对象
	
数据段、栈内存、堆内存、代码段
	栈内存：空间小速度快，存储固定空间的数据，如整型变量
	堆内存：空间大速度慢，存储长度不固定或比较大的数据，如字符串
	代码段：保存程序结构的，包括函数和方法等。

魔术方法：
	是为了完成某功能自动调用的
	在类中写出了某个魔术方法，这个方法对应的功能就会启用，不添加则不启用
	方法名称都是系统定义好的，不是自己定义的
	都是以__开头的，包括：
		__construct();
		__destruct();
		
		__set();
		__get();
		__isset();
		__unset();
		
		__clone();

		__call();

		__sleep();

		__wakeup();

		__toString();

		__autoload();

		......


面向对象特性：封装性

	如果一个变量需要在多个方法中使用，就将这个变量声明为成员属性，这样，可以直接在这个对象的所有方法中使用这个成员属性，相对于这个对象的全局变量。

	php中与asp的property let和property get类似的方法即下面魔术方法中的__set()和__get()，不同的是，asp的每个属性有一个对应的let和get，而php是所有属性共用一个__set()和__get()

	魔术方法：
		__set();
			直接设置私有成员属性值时，自动调用的方法
		__get();
			直接获取私有成员属性值时，自动调用的方法
		__isset();
			直接查看对象中私有属性是否存在时自动调用的方法
		__unset();
			直接删除对象中的私有属性时自动调用的方法

	public：类内部、子类、类外部均可以访问

	protected：只能在类内部和子类中访问

	private：私有的，用这个关键字修饰的成员，只能在对象内部访问。


面向对象特性：继承性

	一、类继承的应用
		c++属于多继承，即同一个类可以有多个父类
		php和java属于单继承，即同一个类只能有一个父类
		但不管是单继承还是多继承，都可以有多个子类
		使用extends关键字来继承父类
		class Student extends Person{

		}

	二、访问类型控制
		子类可以从父类继承所有内容，包括成员属性、成员方法、构造方法……使用方法和使用子类自己的成员一样，但私有成员除外，私有成员只能在所在类中调用
		封装时，让类内部可以使用，让子类也可以使用，但类外部不能使用，可以使用protected

	三、子类中重载父类的方法
		子类可以声明和父类相同的方法名，即子类覆盖了父类中相同的方法

		php的重载和java不同，java重载指的是方法名相同，当方法的参数类型或参数个数不同；但php是弱类型语言，无法确定参数类型，且有默认值的参数可不传值，也就无法确定调用时准确地参数个数，故无法实现java那样的重载。

		在子类中调用父类中被覆盖的方法，使用的是：父类名::方法名(); 或用 parent::方法名(); 可以避免父类改名时也要同时修改

		如果子类中有构造方法，父类中也有构造方法，一定要去调用一次父类中被覆盖的构造方法，否则父类很可能没有正确的初始化

		注意：子类中重载的方法，不能低于父类中的访问权限


常用关键字

	final
		1、final不能修饰成员属性（java中是使用final声明常量的，但php中声明常量是define和const）
		2、final只能修饰类和方法
		作用：
			使用final修饰的类，不能被子类继承
			使用final修饰的方法，不能被子类覆盖

	static
		1、可以修饰成员属性和成员方法，不能修饰类
		2、用static修饰的成员属性，可以被同一个类的所有对象共享
		3、静态的数据是保存在内存数据段中，也叫做初始化静态段
		4、静态的数据是在类被第一次加载时分配到内存中的，以后再用到类时，则直接从数据段中获取
		5、什么是类被加载？只要在程序中使用到这个类，即有这个类名出现？？不用创建对象？？
		6、静态的成员使用类名即可访问，不用创建对象 类名::静态成员; 在类中，self代表本类，可以使用self::静态成员;来访问。
		7、静态方法，不能访问非静态的成员。因为静态方法可通过类直接访问，这时没有对象存在，而非静态成员必须有对象存在才能访问。
		8、如果确定一个方法不用访问非静态成员，则可以声明为静态方法，好处是不用创建对象即可访问。

		思考：单态设计模式，一个类只能创建一个对象？

	const
		1、只能修饰成员属性
		2、类中声明常量属性使用const（define类外？）
		3、除声明方式不同外，其他规则和define一样，如一样没有$，字母全部大写等
			const HOST="www.ssl.com";
		4、访问方式和静态成员属性是一样的，在类外部通过 类名::常量 ,类内部通过  self::常量  的方式。
		5、常量一定要在声明时就给出值。


常用魔术方法

	__call()
		作用：在调用对象中不存在的方法时就会出现系统报错系统退出。用此函数可以处理此类不存在方法的错误调用。

		什么时候调用：在调用一个对象中不存在的方法时自动调用。
		参数1：被调用的不存在的方法的方法名
		参数2 ：调用方法时传的参数数组

		function __call($funcName,$args){

		}

	__toString()
		作用：用来快速获取对象字符串的最便捷方式
		什么时候调用：直接输出对象引用时调用

	__sleep()
		作用：可以将一个对象部分串行化

		      只要这个方法中返回一个数组，数组中有几个成员属性就序列化几个成员属性，如果不加这个方法，则所有成员都被序列化。
		什么时候调用：是在序列化时自动调用的方法

	serialize()
		参数是一个对象，返回的是串行化后的二进制串。

		对象串行化（序列化）：将一个对象转为二进制串

		1.将对象长时间存储在数据库或文件中
		2.将对象在多个php文件中传输

	unserialize()
		参数是对象的二进制串，返回的是对象

	__wakeup()
		作用：
		什么时候调用：是在反序列化时自动调用的方法
				也是对象重新诞生的一个过程，可以在反序列化后重新初始化对象

	__autoload()
		这是唯一一个不在类中添加的魔术方法，其他魔术方法都是在类中添加起作用。
		只要在页面中使用到一个类，只要用到类名就会自动将类名传给这个参数	

		require "one.class.php";
		require "two.class.php";
		require "three.class.php";
		可用下面的函数代替
		function __autoload($className){
			include "./".$className.".class.php";
		}

		$one=new One;
		$one->fun1();
		$two=new two;
		$one->fun1();
		$one=new One;
		$one->fun1();

	__clone()
		作用：只要一个对象一诞生，就要有初始化的动作，克隆对象时同样会触发同样地初始化动作，可以在__clone()方法中为克隆对象初始化，这时$this代表克隆对象，$that代表原本对象。

		什么时候调用：克隆对象时自动调用

		$p=new Person;
		$p1=clone($p);
		这时触发__clone()方法


抽象类、接口和面向对象特性：多态

	抽象类是一种特殊的类
	接口是一种特殊的抽象类
	多态需要使用到抽象类或接口

什么是抽象方法？

	如果一个类中的方法没有方法体，这个方法就是抽象方法，没有方法体是指连{}都没有而是直接使用分号结束，而不是{}中内容为空。

	function test(); //抽象方法

	function test(){ //这个不是没有方法体，而是方法体为空，不是抽象方法

	}

	如果一个方法是抽象方法，就必须使用abstract修饰，即

	abstract function test();

什么是抽象类？

	1、如果一个类中有一个方法是抽象的，则这个类就是抽象类
	2、如果一个类是抽象类，则这个类必须使用abstract修饰
		abstract class Demo{
			abstract function test();
		}
	3、说抽象类是一个特殊的类，就是因为抽象类中有抽象方法，其他和非抽象类相同，即可以声明成员属性、常量、非抽象方法。
	4、抽象类不能实例化对象


疑问：
	1、抽象方法没有方法体，做什么用？
	2、对象中的方法和属性都要通过对象访问（除了常量和静态变量和方法），而抽象类不能实例化对象，则抽象类中的成员不能直接访问

因此：
	要想使用抽象类，必须使用一个类去继承抽象类；但子类继承了抽象类中的抽象方法，子类也称为了抽象类，因此也无法创建对象；因此要想子类可以创建对象，子类就必须重载父类的抽象方法，给抽象方法加上方法体，使子类不再是抽象类。

总结：
	抽象方法中的方法没有方法体，但子类必须实现这个方法。因此抽象类就是在定义一些儿规范，让子类按规范去实现自己的功能。目的就是在并行开发程序模块时不用互相等待，在全部开发完成后，又可以按预定设计整合到一起。

抽象类可多重继承，但任意一层类没有声明为abstract class，就要实现其上的所有层类中定义的抽象方法

abstract class Animal{

    abstract function move();
}

abstract class Bird extends Animal{


    abstract function eat();
}

class XiQue extends Bird{

    public function move(){
    
    }
    public function eat(){
        return 'wahaha'; 
    }
}

$a = new XiQue();
echo $a->eat();

接口==================

	接口是一种特殊的抽象类，接口和抽象类的作用一样

	因为php是单继承的，子类在继承抽象类后，就不能再去继承其他类了

	因此如果既想实现一些儿规范，又想继承一个非抽象类，就要使用接口

	接口和抽象类的对比：

		1、作用相同，都不能创建对象，都需要子类去实现
		2、接口的声明和抽象类不一样
			interface 接口名{

			}
		3、接口被实现的方式不一样
			class Test implements Demo{

			}
		4、接口中的所有方法必须是抽象方法，只能声明抽象方法，不用使用abstract修饰
		5、接口中的成员属性，只能声明常量，不能声明变量
		6、接口中的成员访问权限，都必须是public，抽象类中最低的权限是protected
		7、如果想让子类可以创建对象，则必须实现接口中的全部抽象方法，可以让抽象类去实现接口中的部分方法
		8、接口还可以继承接口，类只能被继承，而接口既可以被继承（被接口继承，不能被类），又可以被实现，如何区分是实现还是继承：主要是看子类是否有修改父接口的行为，即是否重写了父接口的方法。
			类     实现 接口 全部方法  使用implements
			抽象类 实现 接口 部分方法  使用implements
			接口   继承 接口           使用extends

                interface Usb{

                    function insert();

                    function loose();

                }

                abstract class Pc implements Usb{

                    function insert(){
                        return "inseting...."; 
                    }
                }

                class lenovo extends Pc{

                    function loose(){}
                }

                $pc = new lenovo();

                echo $pc->insert();

		9、一个类可以去实现多个接口(按多个规范去开发子类)，接口直接用逗号分隔
			class Test implements Demo2,Demo3,Demo4{

			}

		10、一个类可以在继承一个类的同时，实现一个或多个接口，顺序是先继承后实现，即
			class Test extends Demo1 implements Demo2
		11、使用implements的目的：
			可以实现多个接口，而extends只能继承一个类
			还可以继承一个类

面向对象特性：多态
	多态是面向对象设计的重要特性，它展现了动态绑定的功能，也称为“同名异式”。多态的功能可让软件在开发和维护时，达到充分的延伸性。事实上，多态最直接的定义就是让具有继承关系的不同对象，可以对相同名称的成员函数调用，产生不同的反应效果。

