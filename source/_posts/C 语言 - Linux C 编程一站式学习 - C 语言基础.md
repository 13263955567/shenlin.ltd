---
title: C 语言 - Linux C 编程一站式学习 - C 语言基础
categories: C 语言
tags: C 语言
---

<!--more-->

## 程序的基本概念

![FirstSector](images/FirstSector.jpg)

## 常量、变量、表达式


## 简单函数


## 深入理解函数


## 分支语句


## 循环语句


## 结构体


## 数组


## 编码风格


## gdb


## 排序和查找


## 栈和队列

-----------------------------------------------------------------------------------------------------

## 学习一门编程语言

要注意下面三个方面：

* 提供了哪些儿 Primitive，如基本类型、基本运算符、表达式和语句
* 提供了哪些儿组合规则，如基本类型如何组合成复合类型，基本的表达式和语句如何组合成复合的表达式和语句
* 提供了哪些儿抽象机制，包括数据抽象和过程抽象

## C 标准

old style C, 89, 99, 11

## C 标准库

C 标准由两部分组成：C 的语法和 C 标准库，实现 C 标准，就要实现 C 编译器和 C 标准库

C 标准库定义了一组标准头文件，每个头文件包含一些儿函数、变量、类型声明和宏定义。

Linux 平台使用最广泛的 C 函数库是 glibc，它提供了一组头文件和库文件，最基本最常用的标准库函数和系统函数都在库文件 libc.so

使用数学函数需要包含头文件 math.h，它位于 libm.so 库文件中，编译时需要加 `-lm` 参数来告诉编译器去这个库文件中找

但大部分常用的函数位于 libc.so 库文件中，但编译时无需额外参数，是因为 gcc 默认已经添加了 `-lc` 选项

## char

```c
printf("%d",'3');       //输出 51，是字符 3 的 ASCII 码值
printf("%d",'3'-'0');   //输出 3，字符'3'减去字符'0k后转换为整数值 3
```

## main 函数

main 函数是被操作系统调用的，因此返回值也是给操作系统的。

$? 表示上一条命令的退出状态
```c
$ ./a.out
$ echo $?
```

### main 函数的写法

系统在调用 main 函数时是传递参数的，它的标准形式：
```c
int main(int argc, char *argv[])
```

不使用系统传递的参数也可以这种写法
```c
int main(void)
```

最老的 old style C 的写法
```c
main(){}
```
* 默认返回 int 类型
* 参数类型和个数不确定
* 但这种宽松的规定使得编译器无法检查程序中可能的 bug
* 为了向后的兼容还可以这样写，但会被警告，不推荐的写法

除了上面的形式，其他写法都是错误或不可移植的。

## void

任何表达式都有值和类型两个基本属性

函数 void test(void) 没有返回值，那么表达式 test() 的值是什么呢？

没有返回值的函数的返回类型是 void，则表示它有一个 void 类型的值，这样设计则任何表达式都有值，编译器做语法解析时不用考虑特殊情况

从语义上规定 void 类型的返回值不能参与运算，因此 这种写法不能通过语义检查：test() + 1

这种设计兼顾了语法上的一致和语义上没有矛盾，是 C 的实现方法，其他语言可能使用其他方法，如分为有返回值的函数，和没有返回值的过程 procedure

## 声明和定义

### 变量

只有分配了内存空间的变量声明才可以称为变量定义

声明
```c
short age;
```

定义
```c
short age = 12;
```

## 取模和整除

???取模和取余???
https://wenku.baidu.com/view/7d796163ddccda38376baf58.html

% 取模运算符，即两个数相除的余数，结果的符号总是和被除数相同
```c
#include <stdio.h>
int main(void){
    printf("%d\n",7%-2);  //输出 1
    printf("%d\n",-7%2);  //输出 -1
}
```

整数除法运算总是趋向 0
```c
printf("%d\n",7/2); //3
printf("%d\n",-7/2); //-3
```

## 逻辑运算

关于逻辑运算的数学体系称为布尔代数，以创始人布尔(Boolean Algebra)命名

## return

函数的返回值相当于定义了一个临时变量，临时变量的数据类型和函数的返回类型相同，并且用 return 后面的语句初始化这个临时变量
```c
int i = 20;

if is_even(i)
    printf("%d是偶数\n",i);

int is_even(x){
    return !(x % 2)
}

//执行过程相当于

int i = 20;

x = i;                      //函数内的局部变量 x

int temp_var = !(x % 2)     //函数退出，局部变量 x 被释放，需要创建临时变量 temp_var 来保存函数的返回值

if (temp_var)               //临时变量 temp_var 使用完就释放
    printf("%d是偶数\n",i);
```
* 虽然函数的返回值相当于临时变量，但不能向其赋值，如 is_even(20) = 1;

返回时不用加括号
```c
return 1;

return(1);
```
* 表达式里加括号是为了改变优先级，但这里不起任何作用，所以第一种写法即可

## Dead Code

代码路径 Code Path 里永远执行不到的代码，有 Dead Code 就表示肯定有 Bug，因为不会故意写一行永远不会执行的代码，所以肯定是程序的运行和你的预想不一样

## Hard Coding

硬编码，直接写死在程序里，而不是通过常量、变量来保存

## 递归定义和Base Case

递归定义需要基础条件 Base Case

如阶乘的定义为: n!=n * (n-1)!，即3的阶乘等于3乘以2的阶乘，2的阶乘又等于2乘以1的阶乘，一直到0的阶乘，然后定义0的阶乘等于1

n! = n * (n-1)!
0! = 1

递归和循环是等价的，一些儿语言没有循环只有递归

## Terms

Leap Of Faith 信仰之跃，先假设某个未完成的函数返回结果是正确的，在此基础上完成其他部分。

infinite recursion  无穷递归

infinite loop  无限循环

POSIX time 或者 Epoch time
    Unix 系统诞生于 1969 年，因此所有类 Unix 系统都把 1970-01-01 0:00:00 称为 Epoch time 或 Unix 时间戳

## 循环

下面的例子中 n 忽大忽小，但最后都是 1，不会死循环，这就是著名的 3x+1 问题，目前还未被证明
```c
n = 7;
while (n != 1) {

    if (n % 2 = 0)
        n = n / 2;
    else
        n = n * 3 + 1;
}
```
3x+1 猜想：任取一个自然数，如果它是偶数，我们就把它除以2，如果它是奇数，我们就把它乘3再加上1。使用新得到的新自然数反复变换，最后结果为1。

## 标号

如 switch 语句中的 case,default，goto语句的
```c
switch () {
    case 1:
        printf("1");
        break;
    case 2:
        printf("2");
        break;
    default:
        printf("others");
}

void test(void){

    int i = 0;
    goto mark;
    printf("%d",i);

mark:
    i = 1;
}
```
* goto 不能跨函数

## Duff's Device

达夫设备，一种特殊的代码写法，利用 switch 的语句块和循环语句的语句块没有本质区别，实现了巧妙的代码优化

```c
#include <stdio.h>
int main(void){
    int i = 0,j = 0;
    switch (i) {
        case 0: do {
        case 1:     ++j;
        case 2:     ++j;
        case 3:     ++j;
        case 4:     ++j;
        case 5:     ++j;
        case 6:     printf("%d,",j);
        } while (j < 3);
    }
    printf("\nj = %d\n",j);
}

//输出
1,2,3,4,5,
j = 5
```
http://blog.csdn.net/kingmax26/article/details/5252657

## 后缀运算符

i++ 后缀++
i-- 后缀--
struct.item 结构体访问成员
array[1] 数组下标
func() 函数调用

后缀运算符优先级最高，其次是单目运算符，如正负号、逻辑非!、前缀++、前缀--

## 数据驱动的编程

data-driven programming

写代码时相对于控制流程和算法，选择正确的数据结构是更重要的

举例：根据输入的数字 1~7 输出对应的星期几
```c
void print_day(short);

int main(void){
    int i = 0;
    while(1){
        printf("please input number : ");
        scanf("%d",&i);
        if (i > 0 && i < 8)
            print_day(i);
        else
            printf("err:invalid number\n");
    }
}

//良好的数据结构选择，没有任何的if else 判断
void print_day(short i){
    char dayName[8][10] = {"", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"};
    printf("%s\n",dayName[i]);
}
```

## 随机数

计算机执行的每一条指令的结果都是确定的，没有一条指令的结果是随机的，
因此调用C函数库得到的随机数其实是伪随机数 pseudorandom，是使用数学公式计算出来的确定的数，只是看起来像随机，
随机数的种子即是数学公式里的参数，种子确定的话，其生成的整个随机数序列也是确定和循环的。
从统计上看生成的随机数是接近均匀分布的

C 语言生成随机数需要包含头文件 stdlib.h，使用 rand 函数，没有参数，返回 0 到 RAND_MAX 之间接近均匀分布的整数。
RAND_MAX 是 stdlib.h 中定义的常量，是一个非常大的整数，不同的平台其取值不同
通常使用时通过取模运算(如 rand() % 10)限定生成的值的范围，而不是直接使用默认的 0~RAND_MAX 之间的范围。

srand 可以设定随机数的种子
rand 然后生成随机数

## 常量

定义常量
```c
#define N 20;
```

## 预处理

preprocess

编译器的工作分为预处理和编译两个阶段

以 # 号开头的行表示 预处理指示 Preprocessing Directive

查看文件在预处理之后编译之前的内容，两条命令效果相同
```c
$ gcc -E test.c

$ cpp test.c
```
* cpp 表示 C preprocess

可以看到预处理将会：
* 展开包含的头文件的代码
* 把定义的常量替换为定义的真正数值

## 排序和查找

算法 Algorithm 是用来解决一类问题的，而不是具体的某一个问题


## 栈和队列

数据结构就是数据的组织方式，包含了存储方式和访问方式两层含义，且两者紧密联系，例如：
把同一类型的数据组织成数组，每个元素一个挨着一个的存储，且大小相同，因此使用下标的方式访问。
把同一对象的成员组织成结构体，每个成员也是一个挨着一个的存储，但大小不一样，所以使用点运算符加成员名来访问。

数据的存储方式和访问方式也决定了解决问题需要的算法，同时要设计一个算法也要设计一个相应的数据结构来支持这种算法，
所以 Pascal 语言的设计者 Niklaus Wirth 提出了：算法 + 数据结构 = 程序

